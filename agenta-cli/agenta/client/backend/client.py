# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_dict import remove_none_from_dict
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .types.add_variant_from_base_and_config_response import (
    AddVariantFromBaseAndConfigResponse,
)
from .types.app import App
from .types.app_variant_output import AppVariantOutput
from .types.base_output import BaseOutput
from .types.container_templates_response import ContainerTemplatesResponse
from .types.create_app_output import CreateAppOutput
from .types.create_custom_evaluation import CreateCustomEvaluation
from .types.custom_evaluation_detail import CustomEvaluationDetail
from .types.custom_evaluation_names import CustomEvaluationNames
from .types.custom_evaluation_output import CustomEvaluationOutput
from .types.docker_env_vars import DockerEnvVars
from .types.environment_output import EnvironmentOutput
from .types.evaluation import Evaluation
from .types.evaluation_scenario import EvaluationScenario
from .types.evaluation_scenario_input import EvaluationScenarioInput
from .types.evaluation_scenario_output import EvaluationScenarioOutput
from .types.evaluation_scenario_update_score import EvaluationScenarioUpdateScore
from .types.evaluation_status_enum import EvaluationStatusEnum
from .types.evaluation_type import EvaluationType
from .types.evaluation_type_settings import EvaluationTypeSettings
from .types.evaluation_webhook import EvaluationWebhook
from .types.feedback import Feedback
from .types.get_config_reponse import GetConfigReponse
from .types.http_validation_error import HttpValidationError
from .types.image import Image
from .types.invite_request import InviteRequest
from .types.list_api_keys_output import ListApiKeysOutput
from .types.new_testset import NewTestset
from .types.organization import Organization
from .types.organization_output import OrganizationOutput
from .types.simple_evaluation_output import SimpleEvaluationOutput
from .types.span import Span
from .types.test_set_output_response import TestSetOutputResponse
from .types.test_set_simple_response import TestSetSimpleResponse
from .types.trace import Trace
from .types.uri import Uri
from .types.variant_action import VariantAction

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AgentaApi:
    def __init__(
        self, *, base_url: str, api_key: str, timeout: typing.Optional[float] = 60
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=base_url,
            api_key=api_key,
            httpx_client=httpx.Client(timeout=timeout),
        )

    def list_api_keys(self) -> typing.List[ListApiKeysOutput]:
        """
        List all API keys associated with the authenticated user.

        Args:
        request (Request): The incoming request object.

        Returns:
        List[ListAPIKeysOutput]: A list of API Keys associated with the user.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_api_keys()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListApiKeysOutput], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_api_key(self) -> str:
        """
        Creates an API key for a user.

        Args:
        request (Request): The request object containing the user ID in the request state.

        Returns:
        str: The created API key.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_api_key(self, key_prefix: str) -> typing.Dict[str, typing.Any]:
        """
        Delete an API key with the given key prefix for the authenticated user.

        Args:
        key_prefix (str): The prefix of the API key to be deleted.
        request (Request): The incoming request object.

        Returns:
        dict: A dictionary containing a success message upon successful deletion.

        Raises:
        HTTPException: If the API key is not found or does not belong to the user.

        Parameters:
            - key_prefix: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_api_key(key_prefix="key-prefix")
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def validate_api_key(self, key_prefix: str) -> bool:
        """
        This Function is called by the CLI and is used to validate an API key provided by a user in agenta init setup.
        Returns:
        bool: True. If the request reaches this point, the API key is valid.

        Parameters:
            - key_prefix: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}/validate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_organization_details(self, org_id: str) -> typing.Any:
        """
        Get an organization's details.

        Raises:
        HTTPException: _description_
        Permission Denied

        Returns:
        OrganizationDB Instance

        Parameters:
            - org_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"organizations_ee/{org_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def invite_to_org(self, org_id: str, *, request: InviteRequest) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: This Organization doesn't exist; status_code: 400
        HTTPException: Failed to invite user to organization; status_code: 403
        HTTPException: You cannot invite yourself to your own organization; status_code: 400
        HTTPException: You do not have permission to access this organization; status_code: 500

        Returns:
        JSONResponse: Invited user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def resend_invitation(self, org_id: str, *, request: InviteRequest) -> typing.Any:
        """
        Resend an invitation to a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Resent invitation to user; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite/resend",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_user_to_org(self, org_id: str, *, token: str) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Added user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - token: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/accept",
            ),
            json=jsonable_encoder({"token": token}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_organization(self, *, request: Organization) -> typing.Any:
        """
        Parameters:
            - request: Organization.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations_ee/create"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_organization(
        self,
        org_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Parameters:
            - org_id: str.

            - name: typing.Optional[str].

            - description: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/update",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def health_check(self) -> typing.Any:
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "health"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_profile(self) -> typing.Any:
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "profile"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_app_variants(self, app_id: str) -> typing.List[AppVariantOutput]:
        """
        Retrieve a list of app variants for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve variants for.
        stoken_session (SessionContainer, optional): The session container to verify the user's session. Defaults to Depends(verify_session()).

        Returns:
        List[AppVariantOutput]: A list of app variants for the given app ID.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_app_variants(app_id="app-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/variants"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[AppVariantOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_variant_by_env(self, *, app_id: str, environment: str) -> AppVariantOutput:
        """
        Retrieve the app variant based on the provided app_id and environment.

        Args:
        app_id (str): The ID of the app to retrieve the variant for.
        environment (str): The environment of the app variant to retrieve.
        stoken_session (SessionContainer, optional): The session token container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the app variant is not found (status_code=500), or if a ValueError is raised (status_code=400), or if any other exception is raised (status_code=500).

        Returns:
        AppVariantOutput: The retrieved app variant.

        Parameters:
            - app_id: str.

            - environment: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "apps/get_variant_by_env"
            ),
            params=remove_none_from_dict(
                {"app_id": app_id, "environment": environment}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_apps(
        self,
        *,
        app_name: typing.Optional[str] = None,
        org_id: typing.Optional[str] = None,
    ) -> typing.List[App]:
        """
        Retrieve a list of apps filtered by app_name and org_id.

        Args:
        app_name (Optional[str]): The name of the app to filter by.
        org_id (Optional[str]): The ID of the organization to filter by.
        stoken_session (SessionContainer): The session container.

        Returns:
        List[App]: A list of apps filtered by app_name and org_id.

        Raises:
        HTTPException: If there was an error retrieving the list of apps.

        Parameters:
            - app_name: typing.Optional[str].

            - org_id: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_apps()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            params=remove_none_from_dict({"app_name": app_name, "org_id": org_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[App], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_app(
        self, *, app_name: str, organization_id: typing.Optional[str] = OMIT
    ) -> CreateAppOutput:
        """
        Create a new app for a user or organization.

        Args:
        payload (CreateApp): The payload containing the app name and organization ID (optional).
        stoken_session (SessionContainer): The session container containing the user's session token.

        Returns:
        CreateAppOutput: The output containing the newly created app's ID and name.

        Raises:
        HTTPException: If there is an error creating the app or the user does not have permission to access the app.

        Parameters:
            - app_name: str.

            - organization_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"app_name": app_name}
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateAppOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_variant_from_image(
        self,
        app_id: str,
        *,
        variant_name: str,
        docker_id: str,
        tags: str,
        base_name: typing.Optional[str] = OMIT,
        config_name: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Add a new variant to an app based on a Docker image.

        Args:
        app_id (str): The ID of the app to add the variant to.
        payload (AddVariantFromImagePayload): The payload containing information about the variant to add.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the feature flag is set to "demo" or if the image does not have a tag starting with the registry name (agenta-server) or if the image is not found or if the user does not have access to the app.

        Returns:
        dict: The newly added variant.

        Parameters:
            - app_id: str.

            - variant_name: str.

            - docker_id: str.

            - tags: str.

            - base_name: typing.Optional[str].

            - config_name: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "variant_name": variant_name,
            "docker_id": docker_id,
            "tags": tags,
        }
        if base_name is not OMIT:
            _request["base_name"] = base_name
        if config_name is not OMIT:
            _request["config_name"] = config_name
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"apps/{app_id}/variant/from-image",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_app(self, app_id: str) -> typing.Any:
        """
        Remove app, all its variant, containers and images

        Arguments:
        app -- App to remove

        Parameters:
            - app_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_app_and_variant_from_template(
        self,
        *,
        app_name: str,
        template_id: str,
        env_vars: typing.Dict[str, str],
        organization_id: typing.Optional[str] = OMIT,
    ) -> AppVariantOutput:
        """
        Create an app and variant from a template.

        Args:
        payload (CreateAppVariant): The payload containing the app and variant information.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the user has reached the app limit or if an app with the same name already exists.

        Returns:
        AppVariantOutput: The output of the created app variant.

        Parameters:
            - app_name: str.

            - template_id: str.

            - env_vars: typing.Dict[str, str].

            - organization_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "app_name": app_name,
            "template_id": template_id,
            "env_vars": env_vars,
        }
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "apps/app_and_variant_from_template",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_environments(self, app_id: str) -> typing.List[EnvironmentOutput]:
        """
        Retrieve a list of environments for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve environments for.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        List[EnvironmentOutput]: A list of environment objects.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_environments(app_id="app-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/environments"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EnvironmentOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_variant_from_base_and_config(
        self,
        *,
        base_id: str,
        new_variant_name: str,
        new_config_name: str,
        parameters: typing.Dict[str, typing.Any],
    ) -> AddVariantFromBaseAndConfigResponse:
        """
        Add a new variant based on an existing one.
        Same as POST /config

        Args:
        payload (AddVariantFromBasePayload): Payload containing base variant ID, new variant name, and parameters.
        stoken_session (SessionContainer, optional): Session container. Defaults to result of verify_session().

        Raises:
        HTTPException: Raised if the variant could not be added or accessed.

        Returns:
        Union[AppVariantOutput, Any]: New variant details or exception.

        Parameters:
            - base_id: str.

            - new_variant_name: str.

            - new_config_name: str.

            - parameters: typing.Dict[str, typing.Any].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "variants/from-base"
            ),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "new_variant_name": new_variant_name,
                    "new_config_name": new_config_name,
                    "parameters": parameters,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AddVariantFromBaseAndConfigResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_variant(
        self,
        variant_id: str,
        *,
        action: VariantAction,
        env_vars: typing.Optional[DockerEnvVars] = OMIT,
    ) -> Uri:
        """
        Start a variant of an app.

        Args:
        variant_id (str): The ID of the variant to start.
        action (VariantAction): The action to perform on the variant (start).
        env_vars (Optional[DockerEnvVars], optional): The environment variables to inject to the Docker container. Defaults to None.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        URI: The URL of the started variant.

        Raises:
        HTTPException: If the app container cannot be started.

        Parameters:
            - variant_id: str.

            - action: VariantAction.

            - env_vars: typing.Optional[DockerEnvVars].
        """
        _request: typing.Dict[str, typing.Any] = {"action": action}
        if env_vars is not OMIT:
            _request["env_vars"] = env_vars
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_variant(self, variant_id: str) -> typing.Any:
        """
        Remove a variant from the server.
        In the case it's the last variant using the image, stop the container and remove the image.

        Arguments:
        app_variant -- AppVariant to remove

        Raises:
        HTTPException: If there is a problem removing the app variant

        Parameters:
            - variant_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_variant_parameters(
        self, variant_id: str, *, parameters: typing.Dict[str, typing.Any]
    ) -> typing.Any:
        """
        Updates the parameters for an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        payload (UpdateVariantParameterPayload): The payload containing the updated parameters.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If there is an error while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response containing the updated app variant parameters.

        Parameters:
            - variant_id: str.

            - parameters: typing.Dict[str, typing.Any].
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/parameters",
            ),
            json=jsonable_encoder({"parameters": parameters}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_variant_image(self, variant_id: str, *, request: Image) -> typing.Any:
        """
        Updates the image used in an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        image (Image): The image information to update.

        Raises:
        HTTPException: If an error occurs while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response indicating whether the update was successful or not.

        Parameters:
            - variant_id: str.

            - request: Image.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/image",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_list_evaluations(self, *, app_id: str) -> typing.List[Evaluation]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
        app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
        List[Evaluation]: A list of evaluations.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_list_evaluations(app_id="app-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Evaluation], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_evaluation(
        self,
        *,
        app_id: str,
        variant_ids: typing.List[str],
        evaluation_type: EvaluationType,
        evaluation_type_settings: typing.Optional[EvaluationTypeSettings] = OMIT,
        inputs: typing.List[str],
        testset_id: str,
        status: str,
    ) -> SimpleEvaluationOutput:
        """
        Creates a new comparison table document
        Raises:
        HTTPException: _description_
        Returns:
        _description_

        Parameters:
            - app_id: str.

            - variant_ids: typing.List[str].

            - evaluation_type: EvaluationType.

            - evaluation_type_settings: typing.Optional[EvaluationTypeSettings].

            - inputs: typing.List[str].

            - testset_id: str.

            - status: str.
        """
        _request: typing.Dict[str, typing.Any] = {
            "app_id": app_id,
            "variant_ids": variant_ids,
            "evaluation_type": evaluation_type,
            "inputs": inputs,
            "testset_id": testset_id,
            "status": status,
        }
        if evaluation_type_settings is not OMIT:
            _request["evaluation_type_settings"] = evaluation_type_settings
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimpleEvaluationOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_evaluations(
        self, *, evaluations_ids: typing.List[str]
    ) -> typing.List[str]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters:
            - evaluations_ids: typing.List[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_evaluations(evaluations_ids=[])
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            json=jsonable_encoder({"evaluations_ids": evaluations_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation(self, evaluation_id: str) -> Evaluation:
        """
        Fetches a single evaluation based on its ID.

        Args:
        evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
        Evaluation: The fetched evaluation.

        Parameters:
            - evaluation_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Evaluation, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluation(
        self,
        evaluation_id: str,
        *,
        status: typing.Optional[EvaluationStatusEnum] = OMIT,
        evaluation_type_settings: typing.Optional[EvaluationTypeSettings] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation's status.

        Raises:
        HTTPException: If the columns in the test set do not match with the inputs in the variant.

        Returns:
        None: A 204 No Content status code, indicating that the update was successful.

        Parameters:
            - evaluation_id: str.

            - status: typing.Optional[EvaluationStatusEnum].

            - evaluation_type_settings: typing.Optional[EvaluationTypeSettings].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if status is not OMIT:
            _request["status"] = status
        if evaluation_type_settings is not OMIT:
            _request["evaluation_type_settings"] = evaluation_type_settings
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation_scenarios(
        self, evaluation_id: str
    ) -> typing.List[EvaluationScenario]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
        evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
        HTTPException: If the evaluation is not found or access is denied.

        Returns:
        List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_evaluation_scenarios(evaluation_id="evaluation-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/evaluation_scenarios",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvaluationScenario], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_evaluation_scenario(
        self, evaluation_id: str, *, request: EvaluationScenario
    ) -> typing.Any:
        """
        Create a new evaluation scenario for a given evaluation ID.

        Raises:
        HTTPException: If evaluation not found or access denied.

        Returns:
        None: 204 No Content status code upon success.

        Parameters:
            - evaluation_id: str.

            - request: EvaluationScenario.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/evaluation_scenario",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluation_scenario(
        self,
        evaluation_id: str,
        evaluation_scenario_id: str,
        evaluation_type: EvaluationType,
        *,
        vote: typing.Optional[str] = OMIT,
        score: typing.Optional[EvaluationScenarioUpdateScore] = OMIT,
        correct_answer: typing.Optional[str] = OMIT,
        outputs: typing.Optional[typing.List[EvaluationScenarioOutput]] = OMIT,
        inputs: typing.Optional[typing.List[EvaluationScenarioInput]] = OMIT,
        is_pinned: typing.Optional[bool] = OMIT,
        note: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation scenario's vote or score based on its type.

        Raises:
        HTTPException: If update fails or unauthorized.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_id: str.

            - evaluation_scenario_id: str.

            - evaluation_type: EvaluationType.

            - vote: typing.Optional[str].

            - score: typing.Optional[EvaluationScenarioUpdateScore].

            - correct_answer: typing.Optional[str].

            - outputs: typing.Optional[typing.List[EvaluationScenarioOutput]].

            - inputs: typing.Optional[typing.List[EvaluationScenarioInput]].

            - is_pinned: typing.Optional[bool].

            - note: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if vote is not OMIT:
            _request["vote"] = vote
        if score is not OMIT:
            _request["score"] = score
        if correct_answer is not OMIT:
            _request["correct_answer"] = correct_answer
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if is_pinned is not OMIT:
            _request["is_pinned"] = is_pinned
        if note is not OMIT:
            _request["note"] = note
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/evaluation_scenario/{evaluation_scenario_id}/{evaluation_type}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def evaluate_ai_critique(
        self,
        *,
        correct_answer: str,
        llm_app_prompt_template: typing.Optional[str] = OMIT,
        inputs: typing.List[EvaluationScenarioInput],
        outputs: typing.List[EvaluationScenarioOutput],
        evaluation_prompt_template: typing.Optional[str] = OMIT,
        open_ai_key: typing.Optional[str] = OMIT,
    ) -> str:
        """
        Evaluate AI critique based on the given payload.

        Args:
        payload (AICritiqueCreate): The payload containing data for AI critique evaluation.
        stoken_session (SessionContainer): The session container verified by `verify_session`.

        Returns:
        str: The output of the AI critique evaluation.

        Raises:
        HTTPException: If any exception occurs during the evaluation.

        Parameters:
            - correct_answer: str.

            - llm_app_prompt_template: typing.Optional[str].

            - inputs: typing.List[EvaluationScenarioInput].

            - outputs: typing.List[EvaluationScenarioOutput].

            - evaluation_prompt_template: typing.Optional[str].

            - open_ai_key: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "correct_answer": correct_answer,
            "inputs": inputs,
            "outputs": outputs,
        }
        if llm_app_prompt_template is not OMIT:
            _request["llm_app_prompt_template"] = llm_app_prompt_template
        if evaluation_prompt_template is not OMIT:
            _request["evaluation_prompt_template"] = evaluation_prompt_template
        if open_ai_key is not OMIT:
            _request["open_ai_key"] = open_ai_key
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/evaluation_scenario/ai_critique",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_evaluation_scenario_score(
        self, evaluation_scenario_id: str
    ) -> typing.Dict[str, str]:
        """
        Fetch the score of a specific evaluation scenario.

        Args:
        evaluation_scenario_id: The ID of the evaluation scenario to fetch.
        stoken_session: Session data, verified by `verify_session`.

        Returns:
        Dictionary containing the scenario ID and its score.

        Parameters:
            - evaluation_scenario_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_evaluation_scenario_score(evaluation_scenario_id="evaluation-scenario-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluation_scenario_score(
        self, evaluation_scenario_id: str, *, score: float
    ) -> typing.Any:
        """
        Updates the score of an evaluation scenario.

        Raises:
        HTTPException: Server error if the evaluation update fails.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_scenario_id: str.

            - score: float.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            json=jsonable_encoder({"score": score}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_results(self, evaluation_id: str) -> typing.Any:
        """
        Fetch all the results for one the comparison table

        Arguments:
        evaluation*id -- \_description*

        Returns:
        _description_

        Parameters:
            - evaluation_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/results",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_custom_evaluation(
        self, *, request: CreateCustomEvaluation
    ) -> typing.Any:
        """
        Create evaluation with custom python code.

        Args:

        custom_evaluation_payload (CreateCustomEvaluation): the required payload

        Parameters:
            - request: CreateCustomEvaluation.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/custom_evaluation",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_custom_evaluation(self, id: str) -> CustomEvaluationDetail:
        """
        Get the custom code evaluation detail.

        Args:
        id (str): the id of the custom evaluation

        Returns:
        CustomEvaluationDetail: Detail of the custom evaluation

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/{id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CustomEvaluationDetail, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_custom_evaluation(
        self, id: str, *, request: CreateCustomEvaluation
    ) -> typing.Any:
        """
        Update a custom code evaluation.
        Args:
        id (str): the ID of the custom evaluation to update
        updated_data (CreateCustomEvaluation): the payload with updated data
        stoken_session (SessionContainer): session container for authentication

        Parameters:
            - id: str.

            - request: CreateCustomEvaluation.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/{id}",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_custom_evaluations(
        self, app_id: str
    ) -> typing.List[CustomEvaluationOutput]:
        """
        List the custom code evaluations for a given app.

        Args:
        app_id (str): the id of the app

        Returns:
        List[CustomEvaluationOutput]: a list of custom evaluation

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_custom_evaluations(app_id="app-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/list/{app_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[CustomEvaluationOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_custom_evaluation_names(
        self, app_name: str
    ) -> typing.List[CustomEvaluationNames]:
        """
        Get the names of custom evaluation for a given app.

        Args:
        app_name (str): the name of the app the evaluation belongs to

        Returns:
        List[CustomEvaluationNames]: the list of name of custom evaluations

        Parameters:
            - app_name: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_custom_evaluation_names(app_name="app-name")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/{app_name}/names",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[CustomEvaluationNames], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execute_custom_evaluation(
        self,
        evaluation_id: str,
        *,
        inputs: typing.List[typing.Dict[str, typing.Any]],
        app_id: str,
        variant_id: str,
        correct_answer: str,
        outputs: typing.List[typing.Dict[str, typing.Any]],
    ) -> typing.Any:
        """
        Execute a custom evaluation code.

        Args:
        evaluation_id (str): the custom evaluation id
        payload (ExecuteCustomEvaluationCode): the required payload

        Returns:
        float: the result of the evaluation custom code

        Parameters:
            - evaluation_id: str.

            - inputs: typing.List[typing.Dict[str, typing.Any]].

            - app_id: str.

            - variant_id: str.

            - correct_answer: str.

            - outputs: typing.List[typing.Dict[str, typing.Any]].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/execute/{evaluation_id}",
            ),
            json=jsonable_encoder(
                {
                    "inputs": inputs,
                    "app_id": app_id,
                    "variant_id": variant_id,
                    "correct_answer": correct_answer,
                    "outputs": outputs,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def webhook_example_fake(self) -> EvaluationWebhook:
        """
        Returns a fake score response for example webhook evaluation

        Returns:
        _description_
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/webhook_example_fake",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluationWebhook, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_file(
        self, *, upload_type: str, file: typing.IO, testset_name: str, app_id: str
    ) -> TestSetSimpleResponse:
        """
        Uploads a CSV or JSON file and saves its data to MongoDB.

        Args:
        upload_type : Either a json or csv file.
        file (UploadFile): The CSV or JSON file to upload.
        testset_name (Optional): the name of the testset if provided.

        Returns:
        dict: The result of the upload process.

        Parameters:
            - upload_type: str.

            - file: typing.IO.

            - testset_name: str.

            - app_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/upload"
            ),
            data=jsonable_encoder(
                {
                    "upload_type": upload_type,
                    "testset_name": testset_name,
                    "app_id": app_id,
                }
            ),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_testset(self) -> TestSetSimpleResponse:
        """
        Import JSON testset data from an endpoint and save it to MongoDB.

        Args:
        endpoint (str): An endpoint URL to import data from.
        testset_name (str): the name of the testset if provided.

        Returns:
        dict: The result of the import process.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/endpoint"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_testset(
        self, app_id: str, *, request: NewTestset
    ) -> TestSetSimpleResponse:
        """
        Create a testset with given name and app_name, save the testset to MongoDB.

        Args:
        name (str): name of the test set.
        app_name (str): name of the application.
        testset (Dict[str, str]): test set data.

        Returns:
        str: The id of the test set created.

        Parameters:
            - app_id: str.

            - request: NewTestset.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{app_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_single_testset(self, testset_id: str) -> typing.Any:
        """
        Fetch a specific testset in a MongoDB collection using its \_id.

        Args:
        testset_id (str): The \_id of the testset to fetch.

        Returns:
        The requested testset if found, else an HTTPException.

        Parameters:
            - testset_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_testset(self, testset_id: str, *, request: NewTestset) -> typing.Any:
        """
        Update a testset with given id, update the testset in MongoDB.

        Args:
        testset_id (str): id of the test set to be updated.
        csvdata (NewTestset): New data to replace the old testset.

        Returns:
        str: The id of the test set updated.

        Parameters:
            - testset_id: str.

            - request: NewTestset.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_testsets(self, *, app_id: str) -> typing.List[TestSetOutputResponse]:
        """
        Get all testsets.

        Returns:

        - A list of testset objects.

        Raises:

        - `HTTPException` with status code 404 if no testsets are found.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_testsets(app_id="app-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[TestSetOutputResponse], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_testsets(self, *, testset_ids: typing.List[str]) -> typing.List[str]:
        """
        Delete specific testsets based on their unique IDs.

        Args:
        testset_ids (List[str]): The unique identifiers of the testsets to delete.

        Returns:
        A list of the deleted testsets' IDs.

        Parameters:
            - testset_ids: typing.List[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_testsets(testset_ids=[])
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            json=jsonable_encoder({"testset_ids": testset_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def build_image(self, *, app_id: str, base_name: str, tar_file: typing.IO) -> Image:
        """
        Builds a Docker image from a tar file containing the application code.

        Args:
        app_id (str): The ID of the application to build the image for.
        base_name (str): The base name of the image to build.
        tar_file (UploadFile): The tar file containing the application code.
        stoken_session (SessionContainer): The session container for the user making the request.

        Returns:
        Image: The Docker image that was built.

        Parameters:
            - app_id: str.

            - base_name: str.

            - tar_file: typing.IO.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/build_image"
            ),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            data=jsonable_encoder({}),
            files={"tar_file": tar_file},
            headers=self._client_wrapper.get_headers(),
            timeout=600,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Image, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def restart_container(self, *, variant_id: str) -> typing.Dict[str, typing.Any]:
        """
        Restart docker container.

        Args:
        payload (RestartAppContainer) -- the required data (app_name and variant_name)

        Parameters:
            - variant_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "containers/restart_container",
            ),
            json=jsonable_encoder({"variant_id": variant_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def container_templates(self) -> ContainerTemplatesResponse:
        """
        Returns a list of templates available for creating new containers.

        Parameters:
        stoken_session (SessionContainer): The session container for the user.

        Returns:

        Union[List[Template], str]: A list of templates or an error message.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/templates"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ContainerTemplatesResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def construct_app_container_url(
        self,
        *,
        base_id: typing.Optional[str] = None,
        variant_id: typing.Optional[str] = None,
    ) -> Uri:
        """
        Constructs the URL for an app container based on the provided base_id or variant_id.

        Args:
        base_id (Optional[str]): The ID of the base to use for the app container.
        variant_id (Optional[str]): The ID of the variant to use for the app container.
        stoken_session (SessionContainer): The session container for the user.

        Returns:
        URI: The URI for the app container.

        Raises:
        HTTPException: If the base or variant cannot be found or the user does not have access.

        Parameters:
            - base_id: typing.Optional[str].

            - variant_id: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/container_url"
            ),
            params=remove_none_from_dict(
                {"base_id": base_id, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def deploy_to_environment(
        self, *, environment_name: str, variant_id: str
    ) -> typing.Any:
        """
        Deploys a given variant to an environment

        Args:
        environment_name: Name of the environment to deploy to.
        variant_id: variant id to deploy.
        stoken_session: . Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the deployment fails.

        Parameters:
            - environment_name: str.

            - variant_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "environments/deploy"
            ),
            json=jsonable_encoder(
                {"environment_name": environment_name, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_trace(
        self,
        *,
        app_id: typing.Optional[str] = OMIT,
        variant_id: typing.Optional[str] = OMIT,
        cost: typing.Optional[float] = OMIT,
        latency: float,
        status: str,
        token_consumption: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
        start_time: dt.datetime,
        end_time: dt.datetime,
        spans: typing.List[str],
    ) -> str:
        """
        Parameters:
            - app_id: typing.Optional[str].

            - variant_id: typing.Optional[str].

            - cost: typing.Optional[float].

            - latency: float.

            - status: str.

            - token_consumption: typing.Optional[int].

            - tags: typing.Optional[typing.List[str]].

            - start_time: dt.datetime.

            - end_time: dt.datetime.

            - spans: typing.List[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "latency": latency,
            "status": status,
            "start_time": start_time,
            "end_time": end_time,
            "spans": spans,
        }
        if app_id is not OMIT:
            _request["app_id"] = app_id
        if variant_id is not OMIT:
            _request["variant_id"] = variant_id
        if cost is not OMIT:
            _request["cost"] = cost
        if token_consumption is not OMIT:
            _request["token_consumption"] = token_consumption
        if tags is not OMIT:
            _request["tags"] = tags
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/traces"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_traces(self, app_id: str, variant_id: str) -> typing.List[Trace]:
        """
        Parameters:
            - app_id: str.

            - variant_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_traces(app_id="app-id", variant_id="variant-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{app_id}/{variant_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Trace], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_single_trace(self, trace_id: str) -> Trace:
        """
        Parameters:
            - trace_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Trace, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_trace_status(self, trace_id: str, *, status: str) -> bool:
        """
        Parameters:
            - trace_id: str.

            - status: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            json=jsonable_encoder({"status": status}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_span(
        self,
        *,
        parent_span_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        event_name: str,
        event_type: typing.Optional[str] = OMIT,
        start_time: dt.datetime,
        duration: typing.Optional[int] = OMIT,
        status: str,
        end_time: dt.datetime,
        inputs: typing.Optional[typing.List[str]] = OMIT,
        outputs: typing.Optional[typing.List[str]] = OMIT,
        prompt_template: typing.Optional[str] = OMIT,
        tokens_input: typing.Optional[int] = OMIT,
        tokens_output: typing.Optional[int] = OMIT,
        token_total: typing.Optional[int] = OMIT,
        cost: typing.Optional[float] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
    ) -> str:
        """
        Parameters:
            - parent_span_id: typing.Optional[str].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].

            - event_name: str.

            - event_type: typing.Optional[str].

            - start_time: dt.datetime.

            - duration: typing.Optional[int].

            - status: str.

            - end_time: dt.datetime.

            - inputs: typing.Optional[typing.List[str]].

            - outputs: typing.Optional[typing.List[str]].

            - prompt_template: typing.Optional[str].

            - tokens_input: typing.Optional[int].

            - tokens_output: typing.Optional[int].

            - token_total: typing.Optional[int].

            - cost: typing.Optional[float].

            - tags: typing.Optional[typing.List[str]].
        """
        _request: typing.Dict[str, typing.Any] = {
            "event_name": event_name,
            "start_time": start_time,
            "status": status,
            "end_time": end_time,
        }
        if parent_span_id is not OMIT:
            _request["parent_span_id"] = parent_span_id
        if meta is not OMIT:
            _request["meta"] = meta
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if duration is not OMIT:
            _request["duration"] = duration
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if prompt_template is not OMIT:
            _request["prompt_template"] = prompt_template
        if tokens_input is not OMIT:
            _request["tokens_input"] = tokens_input
        if tokens_output is not OMIT:
            _request["tokens_output"] = tokens_output
        if token_total is not OMIT:
            _request["token_total"] = token_total
        if cost is not OMIT:
            _request["cost"] = cost
        if tags is not OMIT:
            _request["tags"] = tags
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/spans"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_spans_of_trace(self, trace_id: str) -> typing.List[Span]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_spans_of_trace(trace_id="trace-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/spans/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Span], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_feedbacks(self, trace_id: str) -> typing.List[Feedback]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_feedbacks(trace_id="trace-id")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Feedback], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_feedback(
        self,
        trace_id: str,
        *,
        feedback: typing.Optional[str] = OMIT,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> str:
        """
        Parameters:
            - trace_id: str.

            - feedback: typing.Optional[str].

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if feedback is not OMIT:
            _request["feedback"] = feedback
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_feedback(self, trace_id: str, feedback_id: str) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_feedback(
        self,
        trace_id: str,
        feedback_id: str,
        *,
        feedback: str,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.

            - feedback: str.

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        """
        _request: typing.Dict[str, typing.Any] = {"feedback": feedback}
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_organizations(self) -> typing.List[Organization]:
        """
        Returns a list of organizations associated with the user's session.

        Args:
        stoken_session (SessionContainer): The user's session token.

        Returns:
        list[Organization]: A list of organizations associated with the user's session.

        Raises:
        HTTPException: If there is an error retrieving the organizations from the database.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_organizations()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Organization], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_own_org(self) -> OrganizationOutput:
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations/own"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrganizationOutput, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_bases(
        self,
        *,
        app_id: typing.Optional[str] = None,
        base_name: typing.Optional[str] = None,
    ) -> typing.List[BaseOutput]:
        """
        Retrieve a list of bases filtered by app_id and base_name.

        Args:
        request (Request): The incoming request.
        app_id (Optional[str], optional): The ID of the app to filter by. Defaults to None.
        base_name (Optional[str], optional): The name of the base to filter by. Defaults to None.

        Returns:
        List[BaseOutput]: A list of BaseOutput objects representing the filtered bases.

        Raises:
        HTTPException: If there was an error retrieving the bases.

        Parameters:
            - app_id: typing.Optional[str].

            - base_name: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_bases()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "bases"),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[BaseOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_config(
        self,
        *,
        base_id: str,
        config_name: typing.Optional[str] = None,
        environment_name: typing.Optional[str] = None,
    ) -> GetConfigReponse:
        """
        Parameters:
            - base_id: str.

            - config_name: typing.Optional[str].

            - environment_name: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            params=remove_none_from_dict(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "environment_name": environment_name,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetConfigReponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def save_config(
        self,
        *,
        base_id: str,
        config_name: str,
        parameters: typing.Dict[str, typing.Any],
        overwrite: bool,
    ) -> typing.Any:
        """
        Parameters:
            - base_id: str.

            - config_name: str.

            - parameters: typing.Dict[str, typing.Any].

            - overwrite: bool.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "parameters": parameters,
                    "overwrite": overwrite,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAgentaApi:
    def __init__(
        self, *, base_url: str, api_key: str, timeout: typing.Optional[float] = 60
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=base_url,
            api_key=api_key,
            httpx_client=httpx.AsyncClient(timeout=timeout),
        )

    async def list_api_keys(self) -> typing.List[ListApiKeysOutput]:
        """
        List all API keys associated with the authenticated user.

        Args:
        request (Request): The incoming request object.

        Returns:
        List[ListAPIKeysOutput]: A list of API Keys associated with the user.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_api_keys()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListApiKeysOutput], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_api_key(self) -> str:
        """
        Creates an API key for a user.

        Args:
        request (Request): The request object containing the user ID in the request state.

        Returns:
        str: The created API key.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_api_key(self, key_prefix: str) -> typing.Dict[str, typing.Any]:
        """
        Delete an API key with the given key prefix for the authenticated user.

        Args:
        key_prefix (str): The prefix of the API key to be deleted.
        request (Request): The incoming request object.

        Returns:
        dict: A dictionary containing a success message upon successful deletion.

        Raises:
        HTTPException: If the API key is not found or does not belong to the user.

        Parameters:
            - key_prefix: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_api_key(key_prefix="key-prefix")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def validate_api_key(self, key_prefix: str) -> bool:
        """
        This Function is called by the CLI and is used to validate an API key provided by a user in agenta init setup.
        Returns:
        bool: True. If the request reaches this point, the API key is valid.

        Parameters:
            - key_prefix: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}/validate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_organization_details(self, org_id: str) -> typing.Any:
        """
        Get an organization's details.

        Raises:
        HTTPException: _description_
        Permission Denied

        Returns:
        OrganizationDB Instance

        Parameters:
            - org_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"organizations_ee/{org_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def invite_to_org(self, org_id: str, *, request: InviteRequest) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: This Organization doesn't exist; status_code: 400
        HTTPException: Failed to invite user to organization; status_code: 403
        HTTPException: You cannot invite yourself to your own organization; status_code: 400
        HTTPException: You do not have permission to access this organization; status_code: 500

        Returns:
        JSONResponse: Invited user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def resend_invitation(
        self, org_id: str, *, request: InviteRequest
    ) -> typing.Any:
        """
        Resend an invitation to a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Resent invitation to user; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite/resend",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_user_to_org(self, org_id: str, *, token: str) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Added user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - token: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/accept",
            ),
            json=jsonable_encoder({"token": token}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_organization(self, *, request: Organization) -> typing.Any:
        """
        Parameters:
            - request: Organization.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations_ee/create"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_organization(
        self,
        org_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Parameters:
            - org_id: str.

            - name: typing.Optional[str].

            - description: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/update",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def health_check(self) -> typing.Any:
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "health"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_profile(self) -> typing.Any:
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "profile"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_app_variants(self, app_id: str) -> typing.List[AppVariantOutput]:
        """
        Retrieve a list of app variants for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve variants for.
        stoken_session (SessionContainer, optional): The session container to verify the user's session. Defaults to Depends(verify_session()).

        Returns:
        List[AppVariantOutput]: A list of app variants for the given app ID.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_app_variants(app_id="app-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/variants"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[AppVariantOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_variant_by_env(
        self, *, app_id: str, environment: str
    ) -> AppVariantOutput:
        """
        Retrieve the app variant based on the provided app_id and environment.

        Args:
        app_id (str): The ID of the app to retrieve the variant for.
        environment (str): The environment of the app variant to retrieve.
        stoken_session (SessionContainer, optional): The session token container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the app variant is not found (status_code=500), or if a ValueError is raised (status_code=400), or if any other exception is raised (status_code=500).

        Returns:
        AppVariantOutput: The retrieved app variant.

        Parameters:
            - app_id: str.

            - environment: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "apps/get_variant_by_env"
            ),
            params=remove_none_from_dict(
                {"app_id": app_id, "environment": environment}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_apps(
        self,
        *,
        app_name: typing.Optional[str] = None,
        org_id: typing.Optional[str] = None,
    ) -> typing.List[App]:
        """
        Retrieve a list of apps filtered by app_name and org_id.

        Args:
        app_name (Optional[str]): The name of the app to filter by.
        org_id (Optional[str]): The ID of the organization to filter by.
        stoken_session (SessionContainer): The session container.

        Returns:
        List[App]: A list of apps filtered by app_name and org_id.

        Raises:
        HTTPException: If there was an error retrieving the list of apps.

        Parameters:
            - app_name: typing.Optional[str].

            - org_id: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_apps()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            params=remove_none_from_dict({"app_name": app_name, "org_id": org_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[App], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_app(
        self, *, app_name: str, organization_id: typing.Optional[str] = OMIT
    ) -> CreateAppOutput:
        """
        Create a new app for a user or organization.

        Args:
        payload (CreateApp): The payload containing the app name and organization ID (optional).
        stoken_session (SessionContainer): The session container containing the user's session token.

        Returns:
        CreateAppOutput: The output containing the newly created app's ID and name.

        Raises:
        HTTPException: If there is an error creating the app or the user does not have permission to access the app.

        Parameters:
            - app_name: str.

            - organization_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"app_name": app_name}
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateAppOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_variant_from_image(
        self,
        app_id: str,
        *,
        variant_name: str,
        docker_id: str,
        tags: str,
        base_name: typing.Optional[str] = OMIT,
        config_name: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Add a new variant to an app based on a Docker image.

        Args:
        app_id (str): The ID of the app to add the variant to.
        payload (AddVariantFromImagePayload): The payload containing information about the variant to add.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the feature flag is set to "demo" or if the image does not have a tag starting with the registry name (agenta-server) or if the image is not found or if the user does not have access to the app.

        Returns:
        dict: The newly added variant.

        Parameters:
            - app_id: str.

            - variant_name: str.

            - docker_id: str.

            - tags: str.

            - base_name: typing.Optional[str].

            - config_name: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "variant_name": variant_name,
            "docker_id": docker_id,
            "tags": tags,
        }
        if base_name is not OMIT:
            _request["base_name"] = base_name
        if config_name is not OMIT:
            _request["config_name"] = config_name
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"apps/{app_id}/variant/from-image",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_app(self, app_id: str) -> typing.Any:
        """
        Remove app, all its variant, containers and images

        Arguments:
        app -- App to remove

        Parameters:
            - app_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_app_and_variant_from_template(
        self,
        *,
        app_name: str,
        template_id: str,
        env_vars: typing.Dict[str, str],
        organization_id: typing.Optional[str] = OMIT,
    ) -> AppVariantOutput:
        """
        Create an app and variant from a template.

        Args:
        payload (CreateAppVariant): The payload containing the app and variant information.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the user has reached the app limit or if an app with the same name already exists.

        Returns:
        AppVariantOutput: The output of the created app variant.

        Parameters:
            - app_name: str.

            - template_id: str.

            - env_vars: typing.Dict[str, str].

            - organization_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "app_name": app_name,
            "template_id": template_id,
            "env_vars": env_vars,
        }
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "apps/app_and_variant_from_template",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_environments(self, app_id: str) -> typing.List[EnvironmentOutput]:
        """
        Retrieve a list of environments for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve environments for.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        List[EnvironmentOutput]: A list of environment objects.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_environments(app_id="app-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/environments"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EnvironmentOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_variant_from_base_and_config(
        self,
        *,
        base_id: str,
        new_variant_name: str,
        new_config_name: str,
        parameters: typing.Dict[str, typing.Any],
    ) -> AddVariantFromBaseAndConfigResponse:
        """
        Add a new variant based on an existing one.
        Same as POST /config

        Args:
        payload (AddVariantFromBasePayload): Payload containing base variant ID, new variant name, and parameters.
        stoken_session (SessionContainer, optional): Session container. Defaults to result of verify_session().

        Raises:
        HTTPException: Raised if the variant could not be added or accessed.

        Returns:
        Union[AppVariantOutput, Any]: New variant details or exception.

        Parameters:
            - base_id: str.

            - new_variant_name: str.

            - new_config_name: str.

            - parameters: typing.Dict[str, typing.Any].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "variants/from-base"
            ),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "new_variant_name": new_variant_name,
                    "new_config_name": new_config_name,
                    "parameters": parameters,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AddVariantFromBaseAndConfigResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_variant(
        self,
        variant_id: str,
        *,
        action: VariantAction,
        env_vars: typing.Optional[DockerEnvVars] = OMIT,
    ) -> Uri:
        """
        Start a variant of an app.

        Args:
        variant_id (str): The ID of the variant to start.
        action (VariantAction): The action to perform on the variant (start).
        env_vars (Optional[DockerEnvVars], optional): The environment variables to inject to the Docker container. Defaults to None.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        URI: The URL of the started variant.

        Raises:
        HTTPException: If the app container cannot be started.

        Parameters:
            - variant_id: str.

            - action: VariantAction.

            - env_vars: typing.Optional[DockerEnvVars].
        """
        _request: typing.Dict[str, typing.Any] = {"action": action}
        if env_vars is not OMIT:
            _request["env_vars"] = env_vars
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_variant(self, variant_id: str) -> typing.Any:
        """
        Remove a variant from the server.
        In the case it's the last variant using the image, stop the container and remove the image.

        Arguments:
        app_variant -- AppVariant to remove

        Raises:
        HTTPException: If there is a problem removing the app variant

        Parameters:
            - variant_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_variant_parameters(
        self, variant_id: str, *, parameters: typing.Dict[str, typing.Any]
    ) -> typing.Any:
        """
        Updates the parameters for an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        payload (UpdateVariantParameterPayload): The payload containing the updated parameters.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If there is an error while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response containing the updated app variant parameters.

        Parameters:
            - variant_id: str.

            - parameters: typing.Dict[str, typing.Any].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/parameters",
            ),
            json=jsonable_encoder({"parameters": parameters}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_variant_image(
        self, variant_id: str, *, request: Image
    ) -> typing.Any:
        """
        Updates the image used in an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        image (Image): The image information to update.

        Raises:
        HTTPException: If an error occurs while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response indicating whether the update was successful or not.

        Parameters:
            - variant_id: str.

            - request: Image.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/image",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_list_evaluations(self, *, app_id: str) -> typing.List[Evaluation]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
        app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
        List[Evaluation]: A list of evaluations.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_list_evaluations(app_id="app-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Evaluation], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_evaluation(
        self,
        *,
        app_id: str,
        variant_ids: typing.List[str],
        evaluation_type: EvaluationType,
        evaluation_type_settings: typing.Optional[EvaluationTypeSettings] = OMIT,
        inputs: typing.List[str],
        testset_id: str,
        status: str,
    ) -> SimpleEvaluationOutput:
        """
        Creates a new comparison table document
        Raises:
        HTTPException: _description_
        Returns:
        _description_

        Parameters:
            - app_id: str.

            - variant_ids: typing.List[str].

            - evaluation_type: EvaluationType.

            - evaluation_type_settings: typing.Optional[EvaluationTypeSettings].

            - inputs: typing.List[str].

            - testset_id: str.

            - status: str.
        """
        _request: typing.Dict[str, typing.Any] = {
            "app_id": app_id,
            "variant_ids": variant_ids,
            "evaluation_type": evaluation_type,
            "inputs": inputs,
            "testset_id": testset_id,
            "status": status,
        }
        if evaluation_type_settings is not OMIT:
            _request["evaluation_type_settings"] = evaluation_type_settings
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimpleEvaluationOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_evaluations(
        self, *, evaluations_ids: typing.List[str]
    ) -> typing.List[str]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters:
            - evaluations_ids: typing.List[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_evaluations(evaluations_ids=[])
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            json=jsonable_encoder({"evaluations_ids": evaluations_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation(self, evaluation_id: str) -> Evaluation:
        """
        Fetches a single evaluation based on its ID.

        Args:
        evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
        Evaluation: The fetched evaluation.

        Parameters:
            - evaluation_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Evaluation, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluation(
        self,
        evaluation_id: str,
        *,
        status: typing.Optional[EvaluationStatusEnum] = OMIT,
        evaluation_type_settings: typing.Optional[EvaluationTypeSettings] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation's status.

        Raises:
        HTTPException: If the columns in the test set do not match with the inputs in the variant.

        Returns:
        None: A 204 No Content status code, indicating that the update was successful.

        Parameters:
            - evaluation_id: str.

            - status: typing.Optional[EvaluationStatusEnum].

            - evaluation_type_settings: typing.Optional[EvaluationTypeSettings].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if status is not OMIT:
            _request["status"] = status
        if evaluation_type_settings is not OMIT:
            _request["evaluation_type_settings"] = evaluation_type_settings
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation_scenarios(
        self, evaluation_id: str
    ) -> typing.List[EvaluationScenario]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
        evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
        HTTPException: If the evaluation is not found or access is denied.

        Returns:
        List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_evaluation_scenarios(evaluation_id="evaluation-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/evaluation_scenarios",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvaluationScenario], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_evaluation_scenario(
        self, evaluation_id: str, *, request: EvaluationScenario
    ) -> typing.Any:
        """
        Create a new evaluation scenario for a given evaluation ID.

        Raises:
        HTTPException: If evaluation not found or access denied.

        Returns:
        None: 204 No Content status code upon success.

        Parameters:
            - evaluation_id: str.

            - request: EvaluationScenario.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/evaluation_scenario",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluation_scenario(
        self,
        evaluation_id: str,
        evaluation_scenario_id: str,
        evaluation_type: EvaluationType,
        *,
        vote: typing.Optional[str] = OMIT,
        score: typing.Optional[EvaluationScenarioUpdateScore] = OMIT,
        correct_answer: typing.Optional[str] = OMIT,
        outputs: typing.Optional[typing.List[EvaluationScenarioOutput]] = OMIT,
        inputs: typing.Optional[typing.List[EvaluationScenarioInput]] = OMIT,
        is_pinned: typing.Optional[bool] = OMIT,
        note: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation scenario's vote or score based on its type.

        Raises:
        HTTPException: If update fails or unauthorized.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_id: str.

            - evaluation_scenario_id: str.

            - evaluation_type: EvaluationType.

            - vote: typing.Optional[str].

            - score: typing.Optional[EvaluationScenarioUpdateScore].

            - correct_answer: typing.Optional[str].

            - outputs: typing.Optional[typing.List[EvaluationScenarioOutput]].

            - inputs: typing.Optional[typing.List[EvaluationScenarioInput]].

            - is_pinned: typing.Optional[bool].

            - note: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if vote is not OMIT:
            _request["vote"] = vote
        if score is not OMIT:
            _request["score"] = score
        if correct_answer is not OMIT:
            _request["correct_answer"] = correct_answer
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if is_pinned is not OMIT:
            _request["is_pinned"] = is_pinned
        if note is not OMIT:
            _request["note"] = note
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/evaluation_scenario/{evaluation_scenario_id}/{evaluation_type}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def evaluate_ai_critique(
        self,
        *,
        correct_answer: str,
        llm_app_prompt_template: typing.Optional[str] = OMIT,
        inputs: typing.List[EvaluationScenarioInput],
        outputs: typing.List[EvaluationScenarioOutput],
        evaluation_prompt_template: typing.Optional[str] = OMIT,
        open_ai_key: typing.Optional[str] = OMIT,
    ) -> str:
        """
        Evaluate AI critique based on the given payload.

        Args:
        payload (AICritiqueCreate): The payload containing data for AI critique evaluation.
        stoken_session (SessionContainer): The session container verified by `verify_session`.

        Returns:
        str: The output of the AI critique evaluation.

        Raises:
        HTTPException: If any exception occurs during the evaluation.

        Parameters:
            - correct_answer: str.

            - llm_app_prompt_template: typing.Optional[str].

            - inputs: typing.List[EvaluationScenarioInput].

            - outputs: typing.List[EvaluationScenarioOutput].

            - evaluation_prompt_template: typing.Optional[str].

            - open_ai_key: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "correct_answer": correct_answer,
            "inputs": inputs,
            "outputs": outputs,
        }
        if llm_app_prompt_template is not OMIT:
            _request["llm_app_prompt_template"] = llm_app_prompt_template
        if evaluation_prompt_template is not OMIT:
            _request["evaluation_prompt_template"] = evaluation_prompt_template
        if open_ai_key is not OMIT:
            _request["open_ai_key"] = open_ai_key
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/evaluation_scenario/ai_critique",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_evaluation_scenario_score(
        self, evaluation_scenario_id: str
    ) -> typing.Dict[str, str]:
        """
        Fetch the score of a specific evaluation scenario.

        Args:
        evaluation_scenario_id: The ID of the evaluation scenario to fetch.
        stoken_session: Session data, verified by `verify_session`.

        Returns:
        Dictionary containing the scenario ID and its score.

        Parameters:
            - evaluation_scenario_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_evaluation_scenario_score(evaluation_scenario_id="evaluation-scenario-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluation_scenario_score(
        self, evaluation_scenario_id: str, *, score: float
    ) -> typing.Any:
        """
        Updates the score of an evaluation scenario.

        Raises:
        HTTPException: Server error if the evaluation update fails.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_scenario_id: str.

            - score: float.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            json=jsonable_encoder({"score": score}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_results(self, evaluation_id: str) -> typing.Any:
        """
        Fetch all the results for one the comparison table

        Arguments:
        evaluation*id -- \_description*

        Returns:
        _description_

        Parameters:
            - evaluation_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/results",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_custom_evaluation(
        self, *, request: CreateCustomEvaluation
    ) -> typing.Any:
        """
        Create evaluation with custom python code.

        Args:

        custom_evaluation_payload (CreateCustomEvaluation): the required payload

        Parameters:
            - request: CreateCustomEvaluation.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/custom_evaluation",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_custom_evaluation(self, id: str) -> CustomEvaluationDetail:
        """
        Get the custom code evaluation detail.

        Args:
        id (str): the id of the custom evaluation

        Returns:
        CustomEvaluationDetail: Detail of the custom evaluation

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/{id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CustomEvaluationDetail, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_custom_evaluation(
        self, id: str, *, request: CreateCustomEvaluation
    ) -> typing.Any:
        """
        Update a custom code evaluation.
        Args:
        id (str): the ID of the custom evaluation to update
        updated_data (CreateCustomEvaluation): the payload with updated data
        stoken_session (SessionContainer): session container for authentication

        Parameters:
            - id: str.

            - request: CreateCustomEvaluation.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/{id}",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_custom_evaluations(
        self, app_id: str
    ) -> typing.List[CustomEvaluationOutput]:
        """
        List the custom code evaluations for a given app.

        Args:
        app_id (str): the id of the app

        Returns:
        List[CustomEvaluationOutput]: a list of custom evaluation

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_custom_evaluations(app_id="app-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/list/{app_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[CustomEvaluationOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_custom_evaluation_names(
        self, app_name: str
    ) -> typing.List[CustomEvaluationNames]:
        """
        Get the names of custom evaluation for a given app.

        Args:
        app_name (str): the name of the app the evaluation belongs to

        Returns:
        List[CustomEvaluationNames]: the list of name of custom evaluations

        Parameters:
            - app_name: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_custom_evaluation_names(app_name="app-name")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/{app_name}/names",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[CustomEvaluationNames], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execute_custom_evaluation(
        self,
        evaluation_id: str,
        *,
        inputs: typing.List[typing.Dict[str, typing.Any]],
        app_id: str,
        variant_id: str,
        correct_answer: str,
        outputs: typing.List[typing.Dict[str, typing.Any]],
    ) -> typing.Any:
        """
        Execute a custom evaluation code.

        Args:
        evaluation_id (str): the custom evaluation id
        payload (ExecuteCustomEvaluationCode): the required payload

        Returns:
        float: the result of the evaluation custom code

        Parameters:
            - evaluation_id: str.

            - inputs: typing.List[typing.Dict[str, typing.Any]].

            - app_id: str.

            - variant_id: str.

            - correct_answer: str.

            - outputs: typing.List[typing.Dict[str, typing.Any]].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/custom_evaluation/execute/{evaluation_id}",
            ),
            json=jsonable_encoder(
                {
                    "inputs": inputs,
                    "app_id": app_id,
                    "variant_id": variant_id,
                    "correct_answer": correct_answer,
                    "outputs": outputs,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def webhook_example_fake(self) -> EvaluationWebhook:
        """
        Returns a fake score response for example webhook evaluation

        Returns:
        _description_
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/webhook_example_fake",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluationWebhook, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_file(
        self, *, upload_type: str, file: typing.IO, testset_name: str, app_id: str
    ) -> TestSetSimpleResponse:
        """
        Uploads a CSV or JSON file and saves its data to MongoDB.

        Args:
        upload_type : Either a json or csv file.
        file (UploadFile): The CSV or JSON file to upload.
        testset_name (Optional): the name of the testset if provided.

        Returns:
        dict: The result of the upload process.

        Parameters:
            - upload_type: str.

            - file: typing.IO.

            - testset_name: str.

            - app_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/upload"
            ),
            data=jsonable_encoder(
                {
                    "upload_type": upload_type,
                    "testset_name": testset_name,
                    "app_id": app_id,
                }
            ),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_testset(self) -> TestSetSimpleResponse:
        """
        Import JSON testset data from an endpoint and save it to MongoDB.

        Args:
        endpoint (str): An endpoint URL to import data from.
        testset_name (str): the name of the testset if provided.

        Returns:
        dict: The result of the import process.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/endpoint"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_testset(
        self, app_id: str, *, request: NewTestset
    ) -> TestSetSimpleResponse:
        """
        Create a testset with given name and app_name, save the testset to MongoDB.

        Args:
        name (str): name of the test set.
        app_name (str): name of the application.
        testset (Dict[str, str]): test set data.

        Returns:
        str: The id of the test set created.

        Parameters:
            - app_id: str.

            - request: NewTestset.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{app_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_single_testset(self, testset_id: str) -> typing.Any:
        """
        Fetch a specific testset in a MongoDB collection using its \_id.

        Args:
        testset_id (str): The \_id of the testset to fetch.

        Returns:
        The requested testset if found, else an HTTPException.

        Parameters:
            - testset_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_testset(
        self, testset_id: str, *, request: NewTestset
    ) -> typing.Any:
        """
        Update a testset with given id, update the testset in MongoDB.

        Args:
        testset_id (str): id of the test set to be updated.
        csvdata (NewTestset): New data to replace the old testset.

        Returns:
        str: The id of the test set updated.

        Parameters:
            - testset_id: str.

            - request: NewTestset.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_testsets(self, *, app_id: str) -> typing.List[TestSetOutputResponse]:
        """
        Get all testsets.

        Returns:

        - A list of testset objects.

        Raises:

        - `HTTPException` with status code 404 if no testsets are found.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_testsets(app_id="app-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[TestSetOutputResponse], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_testsets(
        self, *, testset_ids: typing.List[str]
    ) -> typing.List[str]:
        """
        Delete specific testsets based on their unique IDs.

        Args:
        testset_ids (List[str]): The unique identifiers of the testsets to delete.

        Returns:
        A list of the deleted testsets' IDs.

        Parameters:
            - testset_ids: typing.List[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_testsets(testset_ids=[])
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            json=jsonable_encoder({"testset_ids": testset_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def build_image(
        self, *, app_id: str, base_name: str, tar_file: typing.IO
    ) -> Image:
        """
        Builds a Docker image from a tar file containing the application code.

        Args:
        app_id (str): The ID of the application to build the image for.
        base_name (str): The base name of the image to build.
        tar_file (UploadFile): The tar file containing the application code.
        stoken_session (SessionContainer): The session container for the user making the request.

        Returns:
        Image: The Docker image that was built.

        Parameters:
            - app_id: str.

            - base_name: str.

            - tar_file: typing.IO.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/build_image"
            ),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            data=jsonable_encoder({}),
            files={"tar_file": tar_file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Image, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def restart_container(
        self, *, variant_id: str
    ) -> typing.Dict[str, typing.Any]:
        """
        Restart docker container.

        Args:
        payload (RestartAppContainer) -- the required data (app_name and variant_name)

        Parameters:
            - variant_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "containers/restart_container",
            ),
            json=jsonable_encoder({"variant_id": variant_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def container_templates(self) -> ContainerTemplatesResponse:
        """
        Returns a list of templates available for creating new containers.

        Parameters:
        stoken_session (SessionContainer): The session container for the user.

        Returns:

        Union[List[Template], str]: A list of templates or an error message.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/templates"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ContainerTemplatesResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def construct_app_container_url(
        self,
        *,
        base_id: typing.Optional[str] = None,
        variant_id: typing.Optional[str] = None,
    ) -> Uri:
        """
        Constructs the URL for an app container based on the provided base_id or variant_id.

        Args:
        base_id (Optional[str]): The ID of the base to use for the app container.
        variant_id (Optional[str]): The ID of the variant to use for the app container.
        stoken_session (SessionContainer): The session container for the user.

        Returns:
        URI: The URI for the app container.

        Raises:
        HTTPException: If the base or variant cannot be found or the user does not have access.

        Parameters:
            - base_id: typing.Optional[str].

            - variant_id: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/container_url"
            ),
            params=remove_none_from_dict(
                {"base_id": base_id, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def deploy_to_environment(
        self, *, environment_name: str, variant_id: str
    ) -> typing.Any:
        """
        Deploys a given variant to an environment

        Args:
        environment_name: Name of the environment to deploy to.
        variant_id: variant id to deploy.
        stoken_session: . Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the deployment fails.

        Parameters:
            - environment_name: str.

            - variant_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "environments/deploy"
            ),
            json=jsonable_encoder(
                {"environment_name": environment_name, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_trace(
        self,
        *,
        app_id: typing.Optional[str] = OMIT,
        variant_id: typing.Optional[str] = OMIT,
        cost: typing.Optional[float] = OMIT,
        latency: float,
        status: str,
        token_consumption: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
        start_time: dt.datetime,
        end_time: dt.datetime,
        spans: typing.List[str],
    ) -> str:
        """
        Parameters:
            - app_id: typing.Optional[str].

            - variant_id: typing.Optional[str].

            - cost: typing.Optional[float].

            - latency: float.

            - status: str.

            - token_consumption: typing.Optional[int].

            - tags: typing.Optional[typing.List[str]].

            - start_time: dt.datetime.

            - end_time: dt.datetime.

            - spans: typing.List[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "latency": latency,
            "status": status,
            "start_time": start_time,
            "end_time": end_time,
            "spans": spans,
        }
        if app_id is not OMIT:
            _request["app_id"] = app_id
        if variant_id is not OMIT:
            _request["variant_id"] = variant_id
        if cost is not OMIT:
            _request["cost"] = cost
        if token_consumption is not OMIT:
            _request["token_consumption"] = token_consumption
        if tags is not OMIT:
            _request["tags"] = tags
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/traces"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_traces(self, app_id: str, variant_id: str) -> typing.List[Trace]:
        """
        Parameters:
            - app_id: str.

            - variant_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_traces(app_id="app-id", variant_id="variant-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{app_id}/{variant_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Trace], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_single_trace(self, trace_id: str) -> Trace:
        """
        Parameters:
            - trace_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Trace, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_trace_status(self, trace_id: str, *, status: str) -> bool:
        """
        Parameters:
            - trace_id: str.

            - status: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            json=jsonable_encoder({"status": status}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_span(
        self,
        *,
        parent_span_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        event_name: str,
        event_type: typing.Optional[str] = OMIT,
        start_time: dt.datetime,
        duration: typing.Optional[int] = OMIT,
        status: str,
        end_time: dt.datetime,
        inputs: typing.Optional[typing.List[str]] = OMIT,
        outputs: typing.Optional[typing.List[str]] = OMIT,
        prompt_template: typing.Optional[str] = OMIT,
        tokens_input: typing.Optional[int] = OMIT,
        tokens_output: typing.Optional[int] = OMIT,
        token_total: typing.Optional[int] = OMIT,
        cost: typing.Optional[float] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
    ) -> str:
        """
        Parameters:
            - parent_span_id: typing.Optional[str].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].

            - event_name: str.

            - event_type: typing.Optional[str].

            - start_time: dt.datetime.

            - duration: typing.Optional[int].

            - status: str.

            - end_time: dt.datetime.

            - inputs: typing.Optional[typing.List[str]].

            - outputs: typing.Optional[typing.List[str]].

            - prompt_template: typing.Optional[str].

            - tokens_input: typing.Optional[int].

            - tokens_output: typing.Optional[int].

            - token_total: typing.Optional[int].

            - cost: typing.Optional[float].

            - tags: typing.Optional[typing.List[str]].
        """
        _request: typing.Dict[str, typing.Any] = {
            "event_name": event_name,
            "start_time": start_time,
            "status": status,
            "end_time": end_time,
        }
        if parent_span_id is not OMIT:
            _request["parent_span_id"] = parent_span_id
        if meta is not OMIT:
            _request["meta"] = meta
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if duration is not OMIT:
            _request["duration"] = duration
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if prompt_template is not OMIT:
            _request["prompt_template"] = prompt_template
        if tokens_input is not OMIT:
            _request["tokens_input"] = tokens_input
        if tokens_output is not OMIT:
            _request["tokens_output"] = tokens_output
        if token_total is not OMIT:
            _request["token_total"] = token_total
        if cost is not OMIT:
            _request["cost"] = cost
        if tags is not OMIT:
            _request["tags"] = tags
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/spans"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_spans_of_trace(self, trace_id: str) -> typing.List[Span]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_spans_of_trace(trace_id="trace-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/spans/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Span], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_feedbacks(self, trace_id: str) -> typing.List[Feedback]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_feedbacks(trace_id="trace-id")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Feedback], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_feedback(
        self,
        trace_id: str,
        *,
        feedback: typing.Optional[str] = OMIT,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> str:
        """
        Parameters:
            - trace_id: str.

            - feedback: typing.Optional[str].

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if feedback is not OMIT:
            _request["feedback"] = feedback
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_feedback(self, trace_id: str, feedback_id: str) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_feedback(
        self,
        trace_id: str,
        feedback_id: str,
        *,
        feedback: str,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.

            - feedback: str.

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        """
        _request: typing.Dict[str, typing.Any] = {"feedback": feedback}
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_organizations(self) -> typing.List[Organization]:
        """
        Returns a list of organizations associated with the user's session.

        Args:
        stoken_session (SessionContainer): The user's session token.

        Returns:
        list[Organization]: A list of organizations associated with the user's session.

        Raises:
        HTTPException: If there is an error retrieving the organizations from the database.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_organizations()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Organization], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_own_org(self) -> OrganizationOutput:
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations/own"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrganizationOutput, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_bases(
        self,
        *,
        app_id: typing.Optional[str] = None,
        base_name: typing.Optional[str] = None,
    ) -> typing.List[BaseOutput]:
        """
        Retrieve a list of bases filtered by app_id and base_name.

        Args:
        request (Request): The incoming request.
        app_id (Optional[str], optional): The ID of the app to filter by. Defaults to None.
        base_name (Optional[str], optional): The name of the base to filter by. Defaults to None.

        Returns:
        List[BaseOutput]: A list of BaseOutput objects representing the filtered bases.

        Raises:
        HTTPException: If there was an error retrieving the bases.

        Parameters:
            - app_id: typing.Optional[str].

            - base_name: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_bases()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "bases"),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[BaseOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_config(
        self,
        *,
        base_id: str,
        config_name: typing.Optional[str] = None,
        environment_name: typing.Optional[str] = None,
    ) -> GetConfigReponse:
        """
        Parameters:
            - base_id: str.

            - config_name: typing.Optional[str].

            - environment_name: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            params=remove_none_from_dict(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "environment_name": environment_name,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetConfigReponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def save_config(
        self,
        *,
        base_id: str,
        config_name: str,
        parameters: typing.Dict[str, typing.Any],
        overwrite: bool,
    ) -> typing.Any:
        """
        Parameters:
            - base_id: str.

            - config_name: str.

            - parameters: typing.Dict[str, typing.Any].

            - overwrite: bool.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "parameters": parameters,
                    "overwrite": overwrite,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
