# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_dict import remove_none_from_dict
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .types.add_variant_from_base_and_config_response import (
    AddVariantFromBaseAndConfigResponse,
)
from .types.app import App
from .types.app_variant_output import AppVariantOutput
from .types.app_variant_output_extended import AppVariantOutputExtended
from .types.base_output import BaseOutput
from .types.container_templates_response import ContainerTemplatesResponse
from .types.create_app_output import CreateAppOutput
from .types.delete_evaluation import DeleteEvaluation
from .types.docker_env_vars import DockerEnvVars
from .types.environment_output import EnvironmentOutput
from .types.evaluation import Evaluation
from .types.evaluation_status_enum import EvaluationStatusEnum
from .types.evaluation_type import EvaluationType
from .types.evaluation_webhook import EvaluationWebhook
from .types.evaluator import Evaluator
from .types.evaluator_config import EvaluatorConfig
from .types.feedback import Feedback
from .types.get_config_reponse import GetConfigReponse
from .types.http_validation_error import HttpValidationError
from .types.human_evaluation import HumanEvaluation
from .types.human_evaluation_scenario import HumanEvaluationScenario
from .types.human_evaluation_scenario_input import HumanEvaluationScenarioInput
from .types.human_evaluation_scenario_output import HumanEvaluationScenarioOutput
from .types.human_evaluation_scenario_update_score import (
    HumanEvaluationScenarioUpdateScore,
)
from .types.image import Image
from .types.invite_request import InviteRequest
from .types.list_api_keys_output import ListApiKeysOutput
from .types.new_testset import NewTestset
from .types.organization import Organization
from .types.organization_output import OrganizationOutput
from .types.simple_evaluation_output import SimpleEvaluationOutput
from .types.span import Span
from .types.test_set_output_response import TestSetOutputResponse
from .types.test_set_simple_response import TestSetSimpleResponse
from .types.trace import Trace
from .types.uri import Uri
from .types.variant_action import VariantAction

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AgentaApi:
    def __init__(
        self, *, base_url: str, api_key: str, timeout: typing.Optional[float] = 60
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=base_url,
            api_key=api_key,
            httpx_client=httpx.Client(timeout=timeout),
        )

    def list_api_keys(self) -> typing.List[ListApiKeysOutput]:
        """
        List all API keys associated with the authenticated user.

        Args:
        request (Request): The incoming request object.

        Returns:
        List[ListAPIKeysOutput]: A list of API Keys associated with the user.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_api_keys()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListApiKeysOutput], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_api_key(self) -> str:
        """
        Creates an API key for a user.

        Args:
        request (Request): The request object containing the user ID in the request state.

        Returns:
        str: The created API key.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_api_key()
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_api_key(self, key_prefix: str) -> typing.Dict[str, typing.Any]:
        """
        Delete an API key with the given key prefix for the authenticated user.

        Args:
        key_prefix (str): The prefix of the API key to be deleted.
        request (Request): The incoming request object.

        Returns:
        dict: A dictionary containing a success message upon successful deletion.

        Raises:
        HTTPException: If the API key is not found or does not belong to the user.

        Parameters:
            - key_prefix: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_api_key(key_prefix="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def validate_api_key(self, key_prefix: str) -> bool:
        """
        This Function is called by the CLI and is used to validate an API key provided by a user in agenta init setup.
        Returns:
        bool: True. If the request reaches this point, the API key is valid.

        Parameters:
            - key_prefix: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.validate_api_key(key_prefix="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}/validate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_organization_details(self, org_id: str) -> typing.Any:
        """
        Get an organization's details.

        Raises:
        HTTPException: _description_
        Permission Denied

        Returns:
        OrganizationDB Instance

        Parameters:
            - org_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_organization_details(org_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"organizations_ee/{org_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def invite_to_org(self, org_id: str, *, request: InviteRequest) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: This Organization doesn't exist; status_code: 400
        HTTPException: Failed to invite user to organization; status_code: 403
        HTTPException: You cannot invite yourself to your own organization; status_code: 400
        HTTPException: You do not have permission to access this organization; status_code: 500

        Returns:
        JSONResponse: Invited user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        ---
        from agenta import InviteRequest
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.invite_to_org(org_id="string", request=InviteRequest(email="string"))
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def resend_invitation(self, org_id: str, *, request: InviteRequest) -> typing.Any:
        """
        Resend an invitation to a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Resent invitation to user; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        ---
        from agenta import InviteRequest
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.resend_invitation(org_id="string", request=InviteRequest(email="string"))
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite/resend",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_user_to_org(self, org_id: str, *, token: str) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Added user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - token: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.add_user_to_org(org_id="string", token="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/accept",
            ),
            json=jsonable_encoder({"token": token}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_organization(self, *, request: Organization) -> typing.Any:
        """
        Parameters:
            - request: Organization.
        ---
        from agenta import Organization
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_organization(request=Organization(name="string", owner="string"))
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations_ee/create"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_organization(
        self,
        org_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Parameters:
            - org_id: str.

            - name: typing.Optional[str].

            - description: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_organization(org_id="string")
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/update",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def health_check(self) -> typing.Any:
        """
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.health_check()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "health"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_profile(self) -> typing.Any:
        """
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.user_profile()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "profile"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_app_variants(self, app_id: str) -> typing.List[AppVariantOutput]:
        """
        Retrieve a list of app variants for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve variants for.
        stoken_session (SessionContainer, optional): The session container to verify the user's session. Defaults to Depends(verify_session()).

        Returns:
        List[AppVariantOutput]: A list of app variants for the given app ID.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_app_variants(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/variants"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[AppVariantOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_apps(
        self,
        *,
        app_name: typing.Optional[str] = None,
        org_id: typing.Optional[str] = None,
    ) -> typing.List[App]:
        """
        Retrieve a list of apps filtered by app_name and org_id.

        Args:
        app_name (Optional[str]): The name of the app to filter by.
        org_id (Optional[str]): The ID of the organization to filter by.
        stoken_session (SessionContainer): The session container.

        Returns:
        List[App]: A list of apps filtered by app_name and org_id.

        Raises:
        HTTPException: If there was an error retrieving the list of apps.

        Parameters:
            - app_name: typing.Optional[str].

            - org_id: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_apps()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            params=remove_none_from_dict({"app_name": app_name, "org_id": org_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[App], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_app(
        self, *, app_name: str, organization_id: typing.Optional[str] = OMIT
    ) -> CreateAppOutput:
        """
        Create a new app for a user or organization.

        Args:
        payload (CreateApp): The payload containing the app name and organization ID (optional).
        stoken_session (SessionContainer): The session container containing the user's session token.

        Returns:
        CreateAppOutput: The output containing the newly created app's ID and name.

        Raises:
        HTTPException: If there is an error creating the app or the user does not have permission to access the app.

        Parameters:
            - app_name: str.

            - organization_id: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_app(app_name="string")
        """
        _request: typing.Dict[str, typing.Any] = {"app_name": app_name}
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateAppOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_variant_from_image(
        self,
        app_id: str,
        *,
        variant_name: str,
        docker_id: str,
        tags: str,
        base_name: typing.Optional[str] = OMIT,
        config_name: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Add a new variant to an app based on a Docker image.

        Args:
        app_id (str): The ID of the app to add the variant to.
        payload (AddVariantFromImagePayload): The payload containing information about the variant to add.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the feature flag is set to "demo" or if the image does not have a tag starting with the registry name (agenta-server) or if the image is not found or if the user does not have access to the app.

        Returns:
        dict: The newly added variant.

        Parameters:
            - app_id: str.

            - variant_name: str.

            - docker_id: str.

            - tags: str.

            - base_name: typing.Optional[str].

            - config_name: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.add_variant_from_image(app_id="string", variant_name="string", docker_id="string", tags="string")
        """
        _request: typing.Dict[str, typing.Any] = {
            "variant_name": variant_name,
            "docker_id": docker_id,
            "tags": tags,
        }
        if base_name is not OMIT:
            _request["base_name"] = base_name
        if config_name is not OMIT:
            _request["config_name"] = config_name
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"apps/{app_id}/variant/from-image",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_app(self, app_id: str) -> typing.Any:
        """
        Remove app, all its variant, containers and images

        Arguments:
        app -- App to remove

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.remove_app(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_app_and_variant_from_template(
        self,
        *,
        app_name: str,
        template_id: str,
        env_vars: typing.Dict[str, str],
        organization_id: typing.Optional[str] = OMIT,
    ) -> AppVariantOutput:
        """
        Create an app and variant from a template.

        Args:
        payload (CreateAppVariant): The payload containing the app and variant information.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the user has reached the app limit or if an app with the same name already exists.

        Returns:
        AppVariantOutput: The output of the created app variant.

        Parameters:
            - app_name: str.

            - template_id: str.

            - env_vars: typing.Dict[str, str].

            - organization_id: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_app_and_variant_from_template(app_name="string", template_id="string", env_vars={"string": "string"})
        """
        _request: typing.Dict[str, typing.Any] = {
            "app_name": app_name,
            "template_id": template_id,
            "env_vars": env_vars,
        }
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "apps/app_and_variant_from_template",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_environments(self, app_id: str) -> typing.List[EnvironmentOutput]:
        """
        Retrieve a list of environments for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve environments for.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        List[EnvironmentOutput]: A list of environment objects.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_environments(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/environments"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EnvironmentOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_variant_from_base_and_config(
        self,
        *,
        base_id: str,
        new_variant_name: str,
        new_config_name: str,
        parameters: typing.Dict[str, typing.Any],
    ) -> AddVariantFromBaseAndConfigResponse:
        """
        Add a new variant based on an existing one.
        Same as POST /config

        Args:
        payload (AddVariantFromBasePayload): Payload containing base variant ID, new variant name, and parameters.
        stoken_session (SessionContainer, optional): Session container. Defaults to result of verify_session().

        Raises:
        HTTPException: Raised if the variant could not be added or accessed.

        Returns:
        Union[AppVariantOutput, Any]: New variant details or exception.

        Parameters:
            - base_id: str.

            - new_variant_name: str.

            - new_config_name: str.

            - parameters: typing.Dict[str, typing.Any].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "variants/from-base"
            ),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "new_variant_name": new_variant_name,
                    "new_config_name": new_config_name,
                    "parameters": parameters,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AddVariantFromBaseAndConfigResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_variant(self, variant_id: str) -> AppVariantOutputExtended:
        """
        Parameters:
            - variant_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_variant(variant_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutputExtended, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_variant(
        self,
        variant_id: str,
        *,
        action: VariantAction,
        env_vars: typing.Optional[DockerEnvVars] = OMIT,
    ) -> Uri:
        """
        Start a variant of an app.

        Args:
        variant_id (str): The ID of the variant to start.
        action (VariantAction): The action to perform on the variant (start).
        env_vars (Optional[DockerEnvVars], optional): The environment variables to inject to the Docker container. Defaults to None.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        URI: The URL of the started variant.

        Raises:
        HTTPException: If the app container cannot be started.

        Parameters:
            - variant_id: str.

            - action: VariantAction.

            - env_vars: typing.Optional[DockerEnvVars].
        ---
        from agenta import DockerEnvVars, VariantAction, VariantActionEnum
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.start_variant(
            variant_id="string",
            action=VariantAction(action=VariantActionEnum.START),
            env_vars=DockerEnvVars(env_vars={"string": "string"}),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"action": action}
        if env_vars is not OMIT:
            _request["env_vars"] = env_vars
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_variant(self, variant_id: str) -> typing.Any:
        """
        Remove a variant from the server.
        In the case it's the last variant using the image, stop the container and remove the image.

        Arguments:
        app_variant -- AppVariant to remove

        Raises:
        HTTPException: If there is a problem removing the app variant

        Parameters:
            - variant_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.remove_variant(variant_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_variant_parameters(
        self, variant_id: str, *, parameters: typing.Dict[str, typing.Any]
    ) -> typing.Any:
        """
        Updates the parameters for an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        payload (UpdateVariantParameterPayload): The payload containing the updated parameters.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If there is an error while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response containing the updated app variant parameters.

        Parameters:
            - variant_id: str.

            - parameters: typing.Dict[str, typing.Any].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_variant_parameters(variant_id="string", parameters={"string": {"unknown": "string", "type": "unknown"}})
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/parameters",
            ),
            json=jsonable_encoder({"parameters": parameters}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_variant_image(self, variant_id: str, *, request: Image) -> typing.Any:
        """
        Updates the image used in an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        image (Image): The image information to update.

        Raises:
        HTTPException: If an error occurs while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response indicating whether the update was successful or not.

        Parameters:
            - variant_id: str.

            - request: Image.
        ---
        from agenta import Image
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_variant_image(variant_id="string", request=Image(docker_id="string", tags="string"))
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/image",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_list_evaluations_evaluations_get(
        self, *, app_id: str
    ) -> typing.List[Evaluation]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
        app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
        List[Evaluation]: A list of evaluations.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_list_evaluations_evaluations_get(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Evaluation], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_evaluation(
        self,
        *,
        app_id: str,
        variant_ids: typing.List[str],
        evaluation_type: EvaluationType,
        inputs: typing.List[str],
        testset_id: str,
        status: str,
    ) -> SimpleEvaluationOutput:
        """
        Creates a new comparison table document
        Raises:
        HTTPException: _description_
        Returns:
        _description_

        Parameters:
            - app_id: str.

            - variant_ids: typing.List[str].

            - evaluation_type: EvaluationType.

            - inputs: typing.List[str].

            - testset_id: str.

            - status: str.
        ---
        from agenta import EvaluationType
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_evaluation(
            app_id="string",
            variant_ids=[],
            evaluation_type=EvaluationType.HUMAN_A_B_TESTING,
            inputs=[],
            testset_id="string",
            status="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "human-evaluations"
            ),
            json=jsonable_encoder(
                {
                    "app_id": app_id,
                    "variant_ids": variant_ids,
                    "evaluation_type": evaluation_type,
                    "inputs": inputs,
                    "testset_id": testset_id,
                    "status": status,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimpleEvaluationOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_evaluations(self, *, request: DeleteEvaluation) -> typing.List[str]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters:
            - request: DeleteEvaluation.
        ---
        from agenta import DeleteEvaluation
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_evaluations(request=DeleteEvaluation(evaluations_ids=[]))
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation_status(self, evaluation_id: str) -> typing.Any:
        """
        Fetches the status of the evaluation.

        Args:
        evaluation_id (str): the evaluation id
        request (Request): the request object

        Returns:
        (str): the evaluation status

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_evaluation_status(evaluation_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/status",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation_results(self, evaluation_id: str) -> typing.Any:
        """
        Fetches the results of the evaluation

        Args:
        evaluation_id (str): the evaluation id
        request (Request): the request object

        Returns:
        _type_: _description_

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_evaluation_results(evaluation_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/results",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation_scenarios(
        self, evaluation_id: str
    ) -> typing.List[HumanEvaluationScenario]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
        evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
        HTTPException: If the evaluation is not found or access is denied.

        Returns:
        List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_evaluation_scenarios(evaluation_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}/evaluation_scenarios",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[HumanEvaluationScenario], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation(self, evaluation_id: str) -> Evaluation:
        """
        Fetches a single evaluation based on its ID.

        Args:
        evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
        Evaluation: The fetched evaluation.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_evaluation(evaluation_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Evaluation, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def webhook_example_fake(self) -> EvaluationWebhook:
        """
        Returns a fake score response for example webhook evaluation

        Returns:
        _description_

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.webhook_example_fake()
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/webhook_example_fake",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluationWebhook, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_evaluation_scenarios_evaluations_evaluation_scenarios_comparison_results_get(
        self, *, evaluations_ids: str
    ) -> typing.Any:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
        evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
        HTTPException: If the evaluation is not found or access is denied.

        Returns:
        List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters:
            - evaluations_ids: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_evaluation_scenarios_evaluations_evaluation_scenarios_comparison_results_get(evaluations_ids="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/evaluation_scenarios/comparison-results",
            ),
            params=remove_none_from_dict({"evaluations_ids": evaluations_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_list_human_evaluations_human_evaluations_get(
        self, *, app_id: str
    ) -> typing.List[HumanEvaluation]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
        app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
        List[HumanEvaluation]: A list of evaluations.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_list_human_evaluations_human_evaluations_get(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "human-evaluations"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[HumanEvaluation], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_evaluations_human_evaluations_delete(
        self, *, request: DeleteEvaluation
    ) -> typing.List[str]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters:
            - request: DeleteEvaluation.
        ---
        from agenta import DeleteEvaluation
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_evaluations_human_evaluations_delete(request=DeleteEvaluation(evaluations_ids=[]))
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "human-evaluations"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_human_evaluation_human_evaluations_evaluation_id_get(
        self, evaluation_id: str
    ) -> HumanEvaluation:
        """
        Fetches a single evaluation based on its ID.

        Args:
        evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
        HumanEvaluation: The fetched evaluation.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_human_evaluation_human_evaluations_evaluation_id_get(evaluation_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(HumanEvaluation, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_human_evaluation(
        self,
        evaluation_id: str,
        *,
        status: typing.Optional[EvaluationStatusEnum] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation's status.

        Raises:
        HTTPException: If the columns in the test set do not match with the inputs in the variant.

        Returns:
        None: A 204 No Content status code, indicating that the update was successful.

        Parameters:
            - evaluation_id: str.

            - status: typing.Optional[EvaluationStatusEnum].
        ---
        from agenta import EvaluationStatusEnum
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_human_evaluation(evaluation_id="string", status=EvaluationStatusEnum.EVALUATION_INITIALIZED)
        """
        _request: typing.Dict[str, typing.Any] = {}
        if status is not OMIT:
            _request["status"] = status
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluation_scenario_router_human_evaluations_evaluation_id_evaluation_scenario_evaluation_scenario_id_evaluation_type_put(
        self,
        evaluation_id: str,
        evaluation_scenario_id: str,
        evaluation_type: EvaluationType,
        *,
        vote: typing.Optional[str] = OMIT,
        score: typing.Optional[HumanEvaluationScenarioUpdateScore] = OMIT,
        correct_answer: typing.Optional[str] = OMIT,
        outputs: typing.Optional[typing.List[HumanEvaluationScenarioOutput]] = OMIT,
        inputs: typing.Optional[typing.List[HumanEvaluationScenarioInput]] = OMIT,
        is_pinned: typing.Optional[bool] = OMIT,
        note: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation scenario's vote or score based on its type.

        Raises:
        HTTPException: If update fails or unauthorized.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_id: str.

            - evaluation_scenario_id: str.

            - evaluation_type: EvaluationType.

            - vote: typing.Optional[str].

            - score: typing.Optional[HumanEvaluationScenarioUpdateScore].

            - correct_answer: typing.Optional[str].

            - outputs: typing.Optional[typing.List[HumanEvaluationScenarioOutput]].

            - inputs: typing.Optional[typing.List[HumanEvaluationScenarioInput]].

            - is_pinned: typing.Optional[bool].

            - note: typing.Optional[str].
        ---
        from agenta import EvaluationType, HumanEvaluationScenarioInput, HumanEvaluationScenarioOutput
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_evaluation_scenario_router_human_evaluations_evaluation_id_evaluation_scenario_evaluation_scenario_id_evaluation_type_put(
            evaluation_id="string",
            evaluation_scenario_id="string",
            evaluation_type=EvaluationType.HUMAN_A_B_TESTING,
            outputs=[HumanEvaluationScenarioOutput(variant_id="string", variant_output="string")],
            inputs=[HumanEvaluationScenarioInput(input_name="string", input_value="string")],
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if vote is not OMIT:
            _request["vote"] = vote
        if score is not OMIT:
            _request["score"] = score
        if correct_answer is not OMIT:
            _request["correct_answer"] = correct_answer
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if is_pinned is not OMIT:
            _request["is_pinned"] = is_pinned
        if note is not OMIT:
            _request["note"] = note
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}/evaluation_scenario/{evaluation_scenario_id}/{evaluation_type}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_get(
        self, evaluation_scenario_id: str
    ) -> typing.Dict[str, str]:
        """
        Fetch the score of a specific evaluation scenario.

        Args:
        evaluation_scenario_id: The ID of the evaluation scenario to fetch.
        stoken_session: Session data, verified by `verify_session`.

        Returns:
        Dictionary containing the scenario ID and its score.

        Parameters:
            - evaluation_scenario_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_get(
            evaluation_scenario_id="string"
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_put(
        self, evaluation_scenario_id: str, *, score: float
    ) -> typing.Any:
        """
        Updates the score of an evaluation scenario.

        Raises:
        HTTPException: Server error if the evaluation update fails.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_scenario_id: str.

            - score: float.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_put(
            evaluation_scenario_id="string", score=1.1
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            json=jsonable_encoder({"score": score}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_results(self, evaluation_id: str) -> typing.Any:
        """
        Fetch all the results for one the comparison table

        Arguments:
        evaluation*id -- \_description*

        Returns:
        _description_

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.fetch_results(evaluation_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}/results",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_evaluators_endpoint_evaluators_get(self) -> typing.List[Evaluator]:
        """
        Endpoint to fetch a list of evaluators.

        Returns:
        List[Evaluator]: A list of evaluator objects.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_evaluators_endpoint_evaluators_get()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluators"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Evaluator], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_evaluator_configs_evaluators_configs_get(
        self, *, app_id: str
    ) -> typing.List[EvaluatorConfig]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
        app_id (str): The ID of the app.

        Returns:
        List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_evaluator_configs_evaluators_configs_get(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluators/configs"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvaluatorConfig], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_new_evaluator_config_evaluators_configs_post(
        self,
        *,
        app_id: str,
        name: str,
        evaluator_key: str,
        settings_values: typing.Dict[str, typing.Any],
    ) -> EvaluatorConfig:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
        app_id (str): The ID of the app.

        Returns:
        EvaluatorConfigDB: Evaluator configuration api model.

        Parameters:
            - app_id: str.

            - name: str.

            - evaluator_key: str.

            - settings_values: typing.Dict[str, typing.Any].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_new_evaluator_config_evaluators_configs_post(
            app_id="string",
            name="string",
            evaluator_key="string",
            settings_values={"string": {"unknown": "string", "type": "unknown"}},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluators/configs"
            ),
            json=jsonable_encoder(
                {
                    "app_id": app_id,
                    "name": name,
                    "evaluator_key": evaluator_key,
                    "settings_values": settings_values,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluatorConfig, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_evaluator_config_evaluators_configs_evaluator_config_id_get(
        self, evaluator_config_id: str
    ) -> EvaluatorConfig:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Returns:
        List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters:
            - evaluator_config_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_evaluator_config_evaluators_configs_evaluator_config_id_get(evaluator_config_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluators/configs/{evaluator_config_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluatorConfig, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluator_config_evaluators_configs_evaluator_config_id_put(
        self,
        evaluator_config_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        evaluator_key: typing.Optional[str] = OMIT,
        settings_values: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> EvaluatorConfig:
        """
        Endpoint to update evaluator configurations for a specific app.

        Returns:
        List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters:
            - evaluator_config_id: str.

            - name: typing.Optional[str].

            - evaluator_key: typing.Optional[str].

            - settings_values: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_evaluator_config_evaluators_configs_evaluator_config_id_put(evaluator_config_id="string")
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if evaluator_key is not OMIT:
            _request["evaluator_key"] = evaluator_key
        if settings_values is not OMIT:
            _request["settings_values"] = settings_values
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluators/configs/{evaluator_config_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluatorConfig, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_evaluator_config_evaluators_configs_evaluator_config_id_delete(
        self, evaluator_config_id: str
    ) -> bool:
        """
        Endpoint to delete a specific evaluator configuration.

        Args:
        evaluator_config_id (str): The unique identifier of the evaluator configuration.

        Returns:
        bool: True if deletion was successful, False otherwise.

        Parameters:
            - evaluator_config_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_evaluator_config_evaluators_configs_evaluator_config_id_delete(evaluator_config_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluators/configs/{evaluator_config_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_file(
        self, *, upload_type: str, file: typing.IO, testset_name: str, app_id: str
    ) -> TestSetSimpleResponse:
        """
        Uploads a CSV or JSON file and saves its data to MongoDB.

        Args:
        upload_type : Either a json or csv file.
        file (UploadFile): The CSV or JSON file to upload.
        testset_name (Optional): the name of the testset if provided.

        Returns:
        dict: The result of the upload process.

        Parameters:
            - upload_type: str.

            - file: typing.IO.

            - testset_name: str.

            - app_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/upload"
            ),
            data=jsonable_encoder(
                {
                    "upload_type": upload_type,
                    "testset_name": testset_name,
                    "app_id": app_id,
                }
            ),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_testset(self) -> TestSetSimpleResponse:
        """
        Import JSON testset data from an endpoint and save it to MongoDB.

        Args:
        endpoint (str): An endpoint URL to import data from.
        testset_name (str): the name of the testset if provided.

        Returns:
        dict: The result of the import process.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.import_testset()
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/endpoint"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_testset(
        self, app_id: str, *, request: NewTestset
    ) -> TestSetSimpleResponse:
        """
        Create a testset with given name and app_name, save the testset to MongoDB.

        Args:
        name (str): name of the test set.
        app_name (str): name of the application.
        testset (Dict[str, str]): test set data.

        Returns:
        str: The id of the test set created.

        Parameters:
            - app_id: str.

            - request: NewTestset.
        ---
        from agenta import NewTestset
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_testset(app_id="string", request=NewTestset(name="string", csvdata=[]))
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{app_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_single_testset(self, testset_id: str) -> typing.Any:
        """
        Fetch a specific testset in a MongoDB collection using its \_id.

        Args:
        testset_id (str): The \_id of the testset to fetch.

        Returns:
        The requested testset if found, else an HTTPException.

        Parameters:
            - testset_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_single_testset(testset_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_testset(self, testset_id: str, *, request: NewTestset) -> typing.Any:
        """
        Update a testset with given id, update the testset in MongoDB.

        Args:
        testset_id (str): id of the test set to be updated.
        csvdata (NewTestset): New data to replace the old testset.

        Returns:
        str: The id of the test set updated.

        Parameters:
            - testset_id: str.

            - request: NewTestset.
        ---
        from agenta import NewTestset
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_testset(testset_id="string", request=NewTestset(name="string", csvdata=[]))
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_testsets(self, *, app_id: str) -> typing.List[TestSetOutputResponse]:
        """
        Get all testsets.

        Returns:

        - A list of testset objects.

        Raises:

        - `HTTPException` with status code 404 if no testsets are found.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_testsets(app_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[TestSetOutputResponse], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_testsets(self, *, testset_ids: typing.List[str]) -> typing.List[str]:
        """
        Delete specific testsets based on their unique IDs.

        Args:
        testset_ids (List[str]): The unique identifiers of the testsets to delete.

        Returns:
        A list of the deleted testsets' IDs.

        Parameters:
            - testset_ids: typing.List[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.delete_testsets(testset_ids=[])
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            json=jsonable_encoder({"testset_ids": testset_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def build_image(self, *, app_id: str, base_name: str, tar_file: typing.IO) -> Image:
        """
        Builds a Docker image from a tar file containing the application code.

        Args:
        app_id (str): The ID of the application to build the image for.
        base_name (str): The base name of the image to build.
        tar_file (UploadFile): The tar file containing the application code.
        stoken_session (SessionContainer): The session container for the user making the request.

        Returns:
        Image: The Docker image that was built.

        Parameters:
            - app_id: str.

            - base_name: str.

            - tar_file: typing.IO.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/build_image"
            ),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            data=jsonable_encoder({}),
            files={"tar_file": tar_file},
            headers=self._client_wrapper.get_headers(),
            timeout=600,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Image, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def restart_container(self, *, variant_id: str) -> typing.Dict[str, typing.Any]:
        """
        Restart docker container.

        Args:
        payload (RestartAppContainer) -- the required data (app_name and variant_name)

        Parameters:
            - variant_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.restart_container(variant_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "containers/restart_container",
            ),
            json=jsonable_encoder({"variant_id": variant_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def container_templates(self) -> ContainerTemplatesResponse:
        """
        Returns a list of templates available for creating new containers.

        Parameters:
        stoken_session (SessionContainer): The session container for the user.

        Returns:

        Union[List[Template], str]: A list of templates or an error message.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/templates"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ContainerTemplatesResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def construct_app_container_url(
        self,
        *,
        base_id: typing.Optional[str] = None,
        variant_id: typing.Optional[str] = None,
    ) -> Uri:
        """
        Constructs the URL for an app container based on the provided base_id or variant_id.

        Args:
        base_id (Optional[str]): The ID of the base to use for the app container.
        variant_id (Optional[str]): The ID of the variant to use for the app container.
        stoken_session (SessionContainer): The session container for the user.

        Returns:
        URI: The URI for the app container.

        Raises:
        HTTPException: If the base or variant cannot be found or the user does not have access.

        Parameters:
            - base_id: typing.Optional[str].

            - variant_id: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.construct_app_container_url()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/container_url"
            ),
            params=remove_none_from_dict(
                {"base_id": base_id, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def deploy_to_environment(
        self, *, environment_name: str, variant_id: str
    ) -> typing.Any:
        """
        Deploys a given variant to an environment

        Args:
        environment_name: Name of the environment to deploy to.
        variant_id: variant id to deploy.
        stoken_session: . Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the deployment fails.

        Parameters:
            - environment_name: str.

            - variant_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.deploy_to_environment(environment_name="string", variant_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "environments/deploy"
            ),
            json=jsonable_encoder(
                {"environment_name": environment_name, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_trace(
        self,
        *,
        app_id: typing.Optional[str] = OMIT,
        variant_id: typing.Optional[str] = OMIT,
        cost: typing.Optional[float] = OMIT,
        latency: float,
        status: str,
        token_consumption: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
        start_time: dt.datetime,
        end_time: dt.datetime,
        spans: typing.List[str],
    ) -> str:
        """
        Parameters:
            - app_id: typing.Optional[str].

            - variant_id: typing.Optional[str].

            - cost: typing.Optional[float].

            - latency: float.

            - status: str.

            - token_consumption: typing.Optional[int].

            - tags: typing.Optional[typing.List[str]].

            - start_time: dt.datetime.

            - end_time: dt.datetime.

            - spans: typing.List[str].
        ---
        import datetime

        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_trace(
            latency=1.1,
            status="string",
            start_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
            end_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
            spans=[],
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "latency": latency,
            "status": status,
            "start_time": start_time,
            "end_time": end_time,
            "spans": spans,
        }
        if app_id is not OMIT:
            _request["app_id"] = app_id
        if variant_id is not OMIT:
            _request["variant_id"] = variant_id
        if cost is not OMIT:
            _request["cost"] = cost
        if token_consumption is not OMIT:
            _request["token_consumption"] = token_consumption
        if tags is not OMIT:
            _request["tags"] = tags
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/traces"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_traces(self, app_id: str, variant_id: str) -> typing.List[Trace]:
        """
        Parameters:
            - app_id: str.

            - variant_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_traces(app_id="string", variant_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{app_id}/{variant_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Trace], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_single_trace(self, trace_id: str) -> Trace:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_single_trace(trace_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Trace, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_trace_status(self, trace_id: str, *, status: str) -> bool:
        """
        Parameters:
            - trace_id: str.

            - status: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_trace_status(trace_id="string", status="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            json=jsonable_encoder({"status": status}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_span(
        self,
        *,
        parent_span_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        event_name: str,
        event_type: typing.Optional[str] = OMIT,
        start_time: dt.datetime,
        duration: typing.Optional[int] = OMIT,
        status: str,
        end_time: dt.datetime,
        inputs: typing.Optional[typing.List[str]] = OMIT,
        outputs: typing.Optional[typing.List[str]] = OMIT,
        prompt_template: typing.Optional[str] = OMIT,
        tokens_input: typing.Optional[int] = OMIT,
        tokens_output: typing.Optional[int] = OMIT,
        token_total: typing.Optional[int] = OMIT,
        cost: typing.Optional[float] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
    ) -> str:
        """
        Parameters:
            - parent_span_id: typing.Optional[str].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].

            - event_name: str.

            - event_type: typing.Optional[str].

            - start_time: dt.datetime.

            - duration: typing.Optional[int].

            - status: str.

            - end_time: dt.datetime.

            - inputs: typing.Optional[typing.List[str]].

            - outputs: typing.Optional[typing.List[str]].

            - prompt_template: typing.Optional[str].

            - tokens_input: typing.Optional[int].

            - tokens_output: typing.Optional[int].

            - token_total: typing.Optional[int].

            - cost: typing.Optional[float].

            - tags: typing.Optional[typing.List[str]].
        ---
        import datetime

        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_span(
            event_name="string",
            start_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
            status="string",
            end_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "event_name": event_name,
            "start_time": start_time,
            "status": status,
            "end_time": end_time,
        }
        if parent_span_id is not OMIT:
            _request["parent_span_id"] = parent_span_id
        if meta is not OMIT:
            _request["meta"] = meta
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if duration is not OMIT:
            _request["duration"] = duration
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if prompt_template is not OMIT:
            _request["prompt_template"] = prompt_template
        if tokens_input is not OMIT:
            _request["tokens_input"] = tokens_input
        if tokens_output is not OMIT:
            _request["tokens_output"] = tokens_output
        if token_total is not OMIT:
            _request["token_total"] = token_total
        if cost is not OMIT:
            _request["cost"] = cost
        if tags is not OMIT:
            _request["tags"] = tags
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/spans"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_spans_of_trace(self, trace_id: str) -> typing.List[Span]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_spans_of_trace(trace_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/spans/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Span], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_feedbacks(self, trace_id: str) -> typing.List[Feedback]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_feedbacks(trace_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Feedback], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_feedback(
        self,
        trace_id: str,
        *,
        feedback: typing.Optional[str] = OMIT,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> str:
        """
        Parameters:
            - trace_id: str.

            - feedback: typing.Optional[str].

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.create_feedback(trace_id="string")
        """
        _request: typing.Dict[str, typing.Any] = {}
        if feedback is not OMIT:
            _request["feedback"] = feedback
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_feedback(self, trace_id: str, feedback_id: str) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_feedback(trace_id="string", feedback_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_feedback(
        self,
        trace_id: str,
        feedback_id: str,
        *,
        feedback: str,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.

            - feedback: str.

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.update_feedback(trace_id="string", feedback_id="string", feedback="string")
        """
        _request: typing.Dict[str, typing.Any] = {"feedback": feedback}
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_organizations(self) -> typing.List[Organization]:
        """
        Returns a list of organizations associated with the user's session.

        Args:
        stoken_session (SessionContainer): The user's session token.

        Returns:
        list[Organization]: A list of organizations associated with the user's session.

        Raises:
        HTTPException: If there is an error retrieving the organizations from the database.

        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_organizations()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Organization], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_own_org(self) -> OrganizationOutput:
        """
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_own_org()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations/own"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrganizationOutput, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_bases(
        self,
        *,
        app_id: typing.Optional[str] = None,
        base_name: typing.Optional[str] = None,
    ) -> typing.List[BaseOutput]:
        """
        Retrieve a list of bases filtered by app_id and base_name.

        Args:
        request (Request): The incoming request.
        app_id (Optional[str], optional): The ID of the app to filter by. Defaults to None.
        base_name (Optional[str], optional): The name of the base to filter by. Defaults to None.

        Returns:
        List[BaseOutput]: A list of BaseOutput objects representing the filtered bases.

        Raises:
        HTTPException: If there was an error retrieving the bases.

        Parameters:
            - app_id: typing.Optional[str].

            - base_name: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.list_bases()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "bases"),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[BaseOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_config(
        self,
        *,
        base_id: str,
        config_name: typing.Optional[str] = None,
        environment_name: typing.Optional[str] = None,
    ) -> GetConfigReponse:
        """
        Parameters:
            - base_id: str.

            - config_name: typing.Optional[str].

            - environment_name: typing.Optional[str].
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.get_config(base_id="string")
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            params=remove_none_from_dict(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "environment_name": environment_name,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetConfigReponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def save_config(
        self,
        *,
        base_id: str,
        config_name: str,
        parameters: typing.Dict[str, typing.Any],
        overwrite: bool,
    ) -> typing.Any:
        """
        Parameters:
            - base_id: str.

            - config_name: str.

            - parameters: typing.Dict[str, typing.Any].

            - overwrite: bool.
        ---
        from agenta.client import AgentaApi

        client = AgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        client.save_config(
            base_id="string",
            config_name="string",
            parameters={"string": {"unknown": "string", "type": "unknown"}},
            overwrite=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "parameters": parameters,
                    "overwrite": overwrite,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAgentaApi:
    def __init__(
        self, *, base_url: str, api_key: str, timeout: typing.Optional[float] = 60
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=base_url,
            api_key=api_key,
            httpx_client=httpx.AsyncClient(timeout=timeout),
        )

    async def list_api_keys(self) -> typing.List[ListApiKeysOutput]:
        """
        List all API keys associated with the authenticated user.

        Args:
        request (Request): The incoming request object.

        Returns:
        List[ListAPIKeysOutput]: A list of API Keys associated with the user.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_api_keys()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ListApiKeysOutput], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_api_key(self) -> str:
        """
        Creates an API key for a user.

        Args:
        request (Request): The request object containing the user ID in the request state.

        Returns:
        str: The created API key.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_api_key()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_api_key(self, key_prefix: str) -> typing.Dict[str, typing.Any]:
        """
        Delete an API key with the given key prefix for the authenticated user.

        Args:
        key_prefix (str): The prefix of the API key to be deleted.
        request (Request): The incoming request object.

        Returns:
        dict: A dictionary containing a success message upon successful deletion.

        Raises:
        HTTPException: If the API key is not found or does not belong to the user.

        Parameters:
            - key_prefix: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_api_key(key_prefix="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def validate_api_key(self, key_prefix: str) -> bool:
        """
        This Function is called by the CLI and is used to validate an API key provided by a user in agenta init setup.
        Returns:
        bool: True. If the request reaches this point, the API key is valid.

        Parameters:
            - key_prefix: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.validate_api_key(key_prefix="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"keys/{key_prefix}/validate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_organization_details(self, org_id: str) -> typing.Any:
        """
        Get an organization's details.

        Raises:
        HTTPException: _description_
        Permission Denied

        Returns:
        OrganizationDB Instance

        Parameters:
            - org_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_organization_details(org_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"organizations_ee/{org_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def invite_to_org(self, org_id: str, *, request: InviteRequest) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: This Organization doesn't exist; status_code: 400
        HTTPException: Failed to invite user to organization; status_code: 403
        HTTPException: You cannot invite yourself to your own organization; status_code: 400
        HTTPException: You do not have permission to access this organization; status_code: 500

        Returns:
        JSONResponse: Invited user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        ---
        from agenta import InviteRequest
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.invite_to_org(org_id="string", request=InviteRequest(email="string"))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def resend_invitation(
        self, org_id: str, *, request: InviteRequest
    ) -> typing.Any:
        """
        Resend an invitation to a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Resent invitation to user; status_code: 200

        Parameters:
            - org_id: str.

            - request: InviteRequest.
        ---
        from agenta import InviteRequest
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.resend_invitation(org_id="string", request=InviteRequest(email="string"))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/invite/resend",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_user_to_org(self, org_id: str, *, token: str) -> typing.Any:
        """
        Invite a user to an Organization.

        Raises:
        HTTPException: _description_; status_code: 500
        HTTPException: Invitation not found or has expired; status_code: 400
        HTTPException: You already belong to this organization; status_code: 400

        Returns:
        JSONResponse: Added user to organization; status_code: 200

        Parameters:
            - org_id: str.

            - token: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.add_user_to_org(org_id="string", token="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/accept",
            ),
            json=jsonable_encoder({"token": token}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_organization(self, *, request: Organization) -> typing.Any:
        """
        Parameters:
            - request: Organization.
        ---
        from agenta import Organization
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_organization(request=Organization(name="string", owner="string"))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations_ee/create"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_organization(
        self,
        org_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Parameters:
            - org_id: str.

            - name: typing.Optional[str].

            - description: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_organization(org_id="string")
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"organizations_ee/{org_id}/update",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def health_check(self) -> typing.Any:
        """
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.health_check()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "health"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_profile(self) -> typing.Any:
        """
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.user_profile()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "profile"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_app_variants(self, app_id: str) -> typing.List[AppVariantOutput]:
        """
        Retrieve a list of app variants for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve variants for.
        stoken_session (SessionContainer, optional): The session container to verify the user's session. Defaults to Depends(verify_session()).

        Returns:
        List[AppVariantOutput]: A list of app variants for the given app ID.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_app_variants(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/variants"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[AppVariantOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_apps(
        self,
        *,
        app_name: typing.Optional[str] = None,
        org_id: typing.Optional[str] = None,
    ) -> typing.List[App]:
        """
        Retrieve a list of apps filtered by app_name and org_id.

        Args:
        app_name (Optional[str]): The name of the app to filter by.
        org_id (Optional[str]): The ID of the organization to filter by.
        stoken_session (SessionContainer): The session container.

        Returns:
        List[App]: A list of apps filtered by app_name and org_id.

        Raises:
        HTTPException: If there was an error retrieving the list of apps.

        Parameters:
            - app_name: typing.Optional[str].

            - org_id: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_apps()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            params=remove_none_from_dict({"app_name": app_name, "org_id": org_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[App], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_app(
        self, *, app_name: str, organization_id: typing.Optional[str] = OMIT
    ) -> CreateAppOutput:
        """
        Create a new app for a user or organization.

        Args:
        payload (CreateApp): The payload containing the app name and organization ID (optional).
        stoken_session (SessionContainer): The session container containing the user's session token.

        Returns:
        CreateAppOutput: The output containing the newly created app's ID and name.

        Raises:
        HTTPException: If there is an error creating the app or the user does not have permission to access the app.

        Parameters:
            - app_name: str.

            - organization_id: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_app(app_name="string")
        """
        _request: typing.Dict[str, typing.Any] = {"app_name": app_name}
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "apps"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateAppOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_variant_from_image(
        self,
        app_id: str,
        *,
        variant_name: str,
        docker_id: str,
        tags: str,
        base_name: typing.Optional[str] = OMIT,
        config_name: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Add a new variant to an app based on a Docker image.

        Args:
        app_id (str): The ID of the app to add the variant to.
        payload (AddVariantFromImagePayload): The payload containing information about the variant to add.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the feature flag is set to "demo" or if the image does not have a tag starting with the registry name (agenta-server) or if the image is not found or if the user does not have access to the app.

        Returns:
        dict: The newly added variant.

        Parameters:
            - app_id: str.

            - variant_name: str.

            - docker_id: str.

            - tags: str.

            - base_name: typing.Optional[str].

            - config_name: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.add_variant_from_image(app_id="string", variant_name="string", docker_id="string", tags="string")
        """
        _request: typing.Dict[str, typing.Any] = {
            "variant_name": variant_name,
            "docker_id": docker_id,
            "tags": tags,
        }
        if base_name is not OMIT:
            _request["base_name"] = base_name
        if config_name is not OMIT:
            _request["config_name"] = config_name
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"apps/{app_id}/variant/from-image",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_app(self, app_id: str) -> typing.Any:
        """
        Remove app, all its variant, containers and images

        Arguments:
        app -- App to remove

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.remove_app(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_app_and_variant_from_template(
        self,
        *,
        app_name: str,
        template_id: str,
        env_vars: typing.Dict[str, str],
        organization_id: typing.Optional[str] = OMIT,
    ) -> AppVariantOutput:
        """
        Create an app and variant from a template.

        Args:
        payload (CreateAppVariant): The payload containing the app and variant information.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the user has reached the app limit or if an app with the same name already exists.

        Returns:
        AppVariantOutput: The output of the created app variant.

        Parameters:
            - app_name: str.

            - template_id: str.

            - env_vars: typing.Dict[str, str].

            - organization_id: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_app_and_variant_from_template(
            app_name="string", template_id="string", env_vars={"string": "string"}
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "app_name": app_name,
            "template_id": template_id,
            "env_vars": env_vars,
        }
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "apps/app_and_variant_from_template",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_environments(self, app_id: str) -> typing.List[EnvironmentOutput]:
        """
        Retrieve a list of environments for a given app ID.

        Args:
        app_id (str): The ID of the app to retrieve environments for.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        List[EnvironmentOutput]: A list of environment objects.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_environments(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"apps/{app_id}/environments"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EnvironmentOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_variant_from_base_and_config(
        self,
        *,
        base_id: str,
        new_variant_name: str,
        new_config_name: str,
        parameters: typing.Dict[str, typing.Any],
    ) -> AddVariantFromBaseAndConfigResponse:
        """
        Add a new variant based on an existing one.
        Same as POST /config

        Args:
        payload (AddVariantFromBasePayload): Payload containing base variant ID, new variant name, and parameters.
        stoken_session (SessionContainer, optional): Session container. Defaults to result of verify_session().

        Raises:
        HTTPException: Raised if the variant could not be added or accessed.

        Returns:
        Union[AppVariantOutput, Any]: New variant details or exception.

        Parameters:
            - base_id: str.

            - new_variant_name: str.

            - new_config_name: str.

            - parameters: typing.Dict[str, typing.Any].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "variants/from-base"
            ),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "new_variant_name": new_variant_name,
                    "new_config_name": new_config_name,
                    "parameters": parameters,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AddVariantFromBaseAndConfigResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_variant(self, variant_id: str) -> AppVariantOutputExtended:
        """
        Parameters:
            - variant_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_variant(variant_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AppVariantOutputExtended, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_variant(
        self,
        variant_id: str,
        *,
        action: VariantAction,
        env_vars: typing.Optional[DockerEnvVars] = OMIT,
    ) -> Uri:
        """
        Start a variant of an app.

        Args:
        variant_id (str): The ID of the variant to start.
        action (VariantAction): The action to perform on the variant (start).
        env_vars (Optional[DockerEnvVars], optional): The environment variables to inject to the Docker container. Defaults to None.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Returns:
        URI: The URL of the started variant.

        Raises:
        HTTPException: If the app container cannot be started.

        Parameters:
            - variant_id: str.

            - action: VariantAction.

            - env_vars: typing.Optional[DockerEnvVars].
        ---
        from agenta import DockerEnvVars, VariantAction, VariantActionEnum
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.start_variant(
            variant_id="string",
            action=VariantAction(action=VariantActionEnum.START),
            env_vars=DockerEnvVars(env_vars={"string": "string"}),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"action": action}
        if env_vars is not OMIT:
            _request["env_vars"] = env_vars
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_variant(self, variant_id: str) -> typing.Any:
        """
        Remove a variant from the server.
        In the case it's the last variant using the image, stop the container and remove the image.

        Arguments:
        app_variant -- AppVariant to remove

        Raises:
        HTTPException: If there is a problem removing the app variant

        Parameters:
            - variant_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.remove_variant(variant_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"variants/{variant_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_variant_parameters(
        self, variant_id: str, *, parameters: typing.Dict[str, typing.Any]
    ) -> typing.Any:
        """
        Updates the parameters for an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        payload (UpdateVariantParameterPayload): The payload containing the updated parameters.
        stoken_session (SessionContainer, optional): The session container. Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If there is an error while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response containing the updated app variant parameters.

        Parameters:
            - variant_id: str.

            - parameters: typing.Dict[str, typing.Any].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_variant_parameters(
            variant_id="string", parameters={"string": {"unknown": "string", "type": "unknown"}}
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/parameters",
            ),
            json=jsonable_encoder({"parameters": parameters}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_variant_image(
        self, variant_id: str, *, request: Image
    ) -> typing.Any:
        """
        Updates the image used in an app variant.

        Args:
        variant_id (str): The ID of the app variant to update.
        image (Image): The image information to update.

        Raises:
        HTTPException: If an error occurs while trying to update the app variant.

        Returns:
        JSONResponse: A JSON response indicating whether the update was successful or not.

        Parameters:
            - variant_id: str.

            - request: Image.
        ---
        from agenta import Image
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_variant_image(variant_id="string", request=Image(docker_id="string", tags="string"))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"variants/{variant_id}/image",
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_list_evaluations_evaluations_get(
        self, *, app_id: str
    ) -> typing.List[Evaluation]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
        app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
        List[Evaluation]: A list of evaluations.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_list_evaluations_evaluations_get(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Evaluation], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_evaluation(
        self,
        *,
        app_id: str,
        variant_ids: typing.List[str],
        evaluation_type: EvaluationType,
        inputs: typing.List[str],
        testset_id: str,
        status: str,
    ) -> SimpleEvaluationOutput:
        """
        Creates a new comparison table document
        Raises:
        HTTPException: _description_
        Returns:
        _description_

        Parameters:
            - app_id: str.

            - variant_ids: typing.List[str].

            - evaluation_type: EvaluationType.

            - inputs: typing.List[str].

            - testset_id: str.

            - status: str.
        ---
        from agenta import EvaluationType
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_evaluation(
            app_id="string",
            variant_ids=[],
            evaluation_type=EvaluationType.HUMAN_A_B_TESTING,
            inputs=[],
            testset_id="string",
            status="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "human-evaluations"
            ),
            json=jsonable_encoder(
                {
                    "app_id": app_id,
                    "variant_ids": variant_ids,
                    "evaluation_type": evaluation_type,
                    "inputs": inputs,
                    "testset_id": testset_id,
                    "status": status,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimpleEvaluationOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_evaluations(
        self, *, request: DeleteEvaluation
    ) -> typing.List[str]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters:
            - request: DeleteEvaluation.
        ---
        from agenta import DeleteEvaluation
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_evaluations(request=DeleteEvaluation(evaluations_ids=[]))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluations"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation_status(self, evaluation_id: str) -> typing.Any:
        """
        Fetches the status of the evaluation.

        Args:
        evaluation_id (str): the evaluation id
        request (Request): the request object

        Returns:
        (str): the evaluation status

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_evaluation_status(evaluation_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/status",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation_results(self, evaluation_id: str) -> typing.Any:
        """
        Fetches the results of the evaluation

        Args:
        evaluation_id (str): the evaluation id
        request (Request): the request object

        Returns:
        _type_: _description_

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_evaluation_results(evaluation_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}/results",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation_scenarios(
        self, evaluation_id: str
    ) -> typing.List[HumanEvaluationScenario]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
        evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
        HTTPException: If the evaluation is not found or access is denied.

        Returns:
        List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_evaluation_scenarios(evaluation_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}/evaluation_scenarios",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[HumanEvaluationScenario], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation(self, evaluation_id: str) -> Evaluation:
        """
        Fetches a single evaluation based on its ID.

        Args:
        evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
        Evaluation: The fetched evaluation.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_evaluation(evaluation_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluations/{evaluation_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Evaluation, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def webhook_example_fake(self) -> EvaluationWebhook:
        """
        Returns a fake score response for example webhook evaluation

        Returns:
        _description_

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.webhook_example_fake()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/webhook_example_fake",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluationWebhook, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_evaluation_scenarios_evaluations_evaluation_scenarios_comparison_results_get(
        self, *, evaluations_ids: str
    ) -> typing.Any:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
        evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
        HTTPException: If the evaluation is not found or access is denied.

        Returns:
        List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters:
            - evaluations_ids: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_evaluation_scenarios_evaluations_evaluation_scenarios_comparison_results_get(
            evaluations_ids="string"
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "evaluations/evaluation_scenarios/comparison-results",
            ),
            params=remove_none_from_dict({"evaluations_ids": evaluations_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_list_human_evaluations_human_evaluations_get(
        self, *, app_id: str
    ) -> typing.List[HumanEvaluation]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
        app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
        List[HumanEvaluation]: A list of evaluations.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_list_human_evaluations_human_evaluations_get(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "human-evaluations"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[HumanEvaluation], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_evaluations_human_evaluations_delete(
        self, *, request: DeleteEvaluation
    ) -> typing.List[str]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters:
            - request: DeleteEvaluation.
        ---
        from agenta import DeleteEvaluation
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_evaluations_human_evaluations_delete(request=DeleteEvaluation(evaluations_ids=[]))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "human-evaluations"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_human_evaluation_human_evaluations_evaluation_id_get(
        self, evaluation_id: str
    ) -> HumanEvaluation:
        """
        Fetches a single evaluation based on its ID.

        Args:
        evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
        HumanEvaluation: The fetched evaluation.

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_human_evaluation_human_evaluations_evaluation_id_get(evaluation_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(HumanEvaluation, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_human_evaluation(
        self,
        evaluation_id: str,
        *,
        status: typing.Optional[EvaluationStatusEnum] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation's status.

        Raises:
        HTTPException: If the columns in the test set do not match with the inputs in the variant.

        Returns:
        None: A 204 No Content status code, indicating that the update was successful.

        Parameters:
            - evaluation_id: str.

            - status: typing.Optional[EvaluationStatusEnum].
        ---
        from agenta import EvaluationStatusEnum
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_human_evaluation(evaluation_id="string", status=EvaluationStatusEnum.EVALUATION_INITIALIZED)
        """
        _request: typing.Dict[str, typing.Any] = {}
        if status is not OMIT:
            _request["status"] = status
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluation_scenario_router_human_evaluations_evaluation_id_evaluation_scenario_evaluation_scenario_id_evaluation_type_put(
        self,
        evaluation_id: str,
        evaluation_scenario_id: str,
        evaluation_type: EvaluationType,
        *,
        vote: typing.Optional[str] = OMIT,
        score: typing.Optional[HumanEvaluationScenarioUpdateScore] = OMIT,
        correct_answer: typing.Optional[str] = OMIT,
        outputs: typing.Optional[typing.List[HumanEvaluationScenarioOutput]] = OMIT,
        inputs: typing.Optional[typing.List[HumanEvaluationScenarioInput]] = OMIT,
        is_pinned: typing.Optional[bool] = OMIT,
        note: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Updates an evaluation scenario's vote or score based on its type.

        Raises:
        HTTPException: If update fails or unauthorized.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_id: str.

            - evaluation_scenario_id: str.

            - evaluation_type: EvaluationType.

            - vote: typing.Optional[str].

            - score: typing.Optional[HumanEvaluationScenarioUpdateScore].

            - correct_answer: typing.Optional[str].

            - outputs: typing.Optional[typing.List[HumanEvaluationScenarioOutput]].

            - inputs: typing.Optional[typing.List[HumanEvaluationScenarioInput]].

            - is_pinned: typing.Optional[bool].

            - note: typing.Optional[str].
        ---
        from agenta import EvaluationType, HumanEvaluationScenarioInput, HumanEvaluationScenarioOutput
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_evaluation_scenario_router_human_evaluations_evaluation_id_evaluation_scenario_evaluation_scenario_id_evaluation_type_put(
            evaluation_id="string",
            evaluation_scenario_id="string",
            evaluation_type=EvaluationType.HUMAN_A_B_TESTING,
            outputs=[HumanEvaluationScenarioOutput(variant_id="string", variant_output="string")],
            inputs=[HumanEvaluationScenarioInput(input_name="string", input_value="string")],
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if vote is not OMIT:
            _request["vote"] = vote
        if score is not OMIT:
            _request["score"] = score
        if correct_answer is not OMIT:
            _request["correct_answer"] = correct_answer
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if is_pinned is not OMIT:
            _request["is_pinned"] = is_pinned
        if note is not OMIT:
            _request["note"] = note
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}/evaluation_scenario/{evaluation_scenario_id}/{evaluation_type}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_get(
        self, evaluation_scenario_id: str
    ) -> typing.Dict[str, str]:
        """
        Fetch the score of a specific evaluation scenario.

        Args:
        evaluation_scenario_id: The ID of the evaluation scenario to fetch.
        stoken_session: Session data, verified by `verify_session`.

        Returns:
        Dictionary containing the scenario ID and its score.

        Parameters:
            - evaluation_scenario_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_get(
            evaluation_scenario_id="string"
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_put(
        self, evaluation_scenario_id: str, *, score: float
    ) -> typing.Any:
        """
        Updates the score of an evaluation scenario.

        Raises:
        HTTPException: Server error if the evaluation update fails.

        Returns:
        None: 204 No Content status code upon successful update.

        Parameters:
            - evaluation_scenario_id: str.

            - score: float.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_evaluation_scenario_score_router_human_evaluations_evaluation_scenario_evaluation_scenario_id_score_put(
            evaluation_scenario_id="string", score=1.1
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/evaluation_scenario/{evaluation_scenario_id}/score",
            ),
            json=jsonable_encoder({"score": score}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_results(self, evaluation_id: str) -> typing.Any:
        """
        Fetch all the results for one the comparison table

        Arguments:
        evaluation*id -- \_description*

        Returns:
        _description_

        Parameters:
            - evaluation_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.fetch_results(evaluation_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"human-evaluations/{evaluation_id}/results",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_evaluators_endpoint_evaluators_get(self) -> typing.List[Evaluator]:
        """
        Endpoint to fetch a list of evaluators.

        Returns:
        List[Evaluator]: A list of evaluator objects.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_evaluators_endpoint_evaluators_get()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluators"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Evaluator], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_evaluator_configs_evaluators_configs_get(
        self, *, app_id: str
    ) -> typing.List[EvaluatorConfig]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
        app_id (str): The ID of the app.

        Returns:
        List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_evaluator_configs_evaluators_configs_get(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluators/configs"
            ),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvaluatorConfig], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_new_evaluator_config_evaluators_configs_post(
        self,
        *,
        app_id: str,
        name: str,
        evaluator_key: str,
        settings_values: typing.Dict[str, typing.Any],
    ) -> EvaluatorConfig:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
        app_id (str): The ID of the app.

        Returns:
        EvaluatorConfigDB: Evaluator configuration api model.

        Parameters:
            - app_id: str.

            - name: str.

            - evaluator_key: str.

            - settings_values: typing.Dict[str, typing.Any].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_new_evaluator_config_evaluators_configs_post(
            app_id="string",
            name="string",
            evaluator_key="string",
            settings_values={"string": {"unknown": "string", "type": "unknown"}},
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "evaluators/configs"
            ),
            json=jsonable_encoder(
                {
                    "app_id": app_id,
                    "name": name,
                    "evaluator_key": evaluator_key,
                    "settings_values": settings_values,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluatorConfig, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_evaluator_config_evaluators_configs_evaluator_config_id_get(
        self, evaluator_config_id: str
    ) -> EvaluatorConfig:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Returns:
        List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters:
            - evaluator_config_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_evaluator_config_evaluators_configs_evaluator_config_id_get(evaluator_config_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluators/configs/{evaluator_config_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluatorConfig, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluator_config_evaluators_configs_evaluator_config_id_put(
        self,
        evaluator_config_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        evaluator_key: typing.Optional[str] = OMIT,
        settings_values: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> EvaluatorConfig:
        """
        Endpoint to update evaluator configurations for a specific app.

        Returns:
        List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters:
            - evaluator_config_id: str.

            - name: typing.Optional[str].

            - evaluator_key: typing.Optional[str].

            - settings_values: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_evaluator_config_evaluators_configs_evaluator_config_id_put(evaluator_config_id="string")
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if evaluator_key is not OMIT:
            _request["evaluator_key"] = evaluator_key
        if settings_values is not OMIT:
            _request["settings_values"] = settings_values
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluators/configs/{evaluator_config_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvaluatorConfig, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_evaluator_config_evaluators_configs_evaluator_config_id_delete(
        self, evaluator_config_id: str
    ) -> bool:
        """
        Endpoint to delete a specific evaluator configuration.

        Args:
        evaluator_config_id (str): The unique identifier of the evaluator configuration.

        Returns:
        bool: True if deletion was successful, False otherwise.

        Parameters:
            - evaluator_config_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_evaluator_config_evaluators_configs_evaluator_config_id_delete(evaluator_config_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"evaluators/configs/{evaluator_config_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_file(
        self, *, upload_type: str, file: typing.IO, testset_name: str, app_id: str
    ) -> TestSetSimpleResponse:
        """
        Uploads a CSV or JSON file and saves its data to MongoDB.

        Args:
        upload_type : Either a json or csv file.
        file (UploadFile): The CSV or JSON file to upload.
        testset_name (Optional): the name of the testset if provided.

        Returns:
        dict: The result of the upload process.

        Parameters:
            - upload_type: str.

            - file: typing.IO.

            - testset_name: str.

            - app_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/upload"
            ),
            data=jsonable_encoder(
                {
                    "upload_type": upload_type,
                    "testset_name": testset_name,
                    "app_id": app_id,
                }
            ),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_testset(self) -> TestSetSimpleResponse:
        """
        Import JSON testset data from an endpoint and save it to MongoDB.

        Args:
        endpoint (str): An endpoint URL to import data from.
        testset_name (str): the name of the testset if provided.

        Returns:
        dict: The result of the import process.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.import_testset()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "testsets/endpoint"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_testset(
        self, app_id: str, *, request: NewTestset
    ) -> TestSetSimpleResponse:
        """
        Create a testset with given name and app_name, save the testset to MongoDB.

        Args:
        name (str): name of the test set.
        app_name (str): name of the application.
        testset (Dict[str, str]): test set data.

        Returns:
        str: The id of the test set created.

        Parameters:
            - app_id: str.

            - request: NewTestset.
        ---
        from agenta import NewTestset
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_testset(app_id="string", request=NewTestset(name="string", csvdata=[]))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{app_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TestSetSimpleResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_single_testset(self, testset_id: str) -> typing.Any:
        """
        Fetch a specific testset in a MongoDB collection using its \_id.

        Args:
        testset_id (str): The \_id of the testset to fetch.

        Returns:
        The requested testset if found, else an HTTPException.

        Parameters:
            - testset_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_single_testset(testset_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_testset(
        self, testset_id: str, *, request: NewTestset
    ) -> typing.Any:
        """
        Update a testset with given id, update the testset in MongoDB.

        Args:
        testset_id (str): id of the test set to be updated.
        csvdata (NewTestset): New data to replace the old testset.

        Returns:
        str: The id of the test set updated.

        Parameters:
            - testset_id: str.

            - request: NewTestset.
        ---
        from agenta import NewTestset
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_testset(testset_id="string", request=NewTestset(name="string", csvdata=[]))
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"testsets/{testset_id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_testsets(self, *, app_id: str) -> typing.List[TestSetOutputResponse]:
        """
        Get all testsets.

        Returns:

        - A list of testset objects.

        Raises:

        - `HTTPException` with status code 404 if no testsets are found.

        Parameters:
            - app_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_testsets(app_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            params=remove_none_from_dict({"app_id": app_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[TestSetOutputResponse], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_testsets(
        self, *, testset_ids: typing.List[str]
    ) -> typing.List[str]:
        """
        Delete specific testsets based on their unique IDs.

        Args:
        testset_ids (List[str]): The unique identifiers of the testsets to delete.

        Returns:
        A list of the deleted testsets' IDs.

        Parameters:
            - testset_ids: typing.List[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.delete_testsets(testset_ids=[])
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "testsets"),
            json=jsonable_encoder({"testset_ids": testset_ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[str], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def build_image(
        self, *, app_id: str, base_name: str, tar_file: typing.IO
    ) -> Image:
        """
        Builds a Docker image from a tar file containing the application code.

        Args:
        app_id (str): The ID of the application to build the image for.
        base_name (str): The base name of the image to build.
        tar_file (UploadFile): The tar file containing the application code.
        stoken_session (SessionContainer): The session container for the user making the request.

        Returns:
        Image: The Docker image that was built.

        Parameters:
            - app_id: str.

            - base_name: str.

            - tar_file: typing.IO.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/build_image"
            ),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            data=jsonable_encoder({}),
            files={"tar_file": tar_file},
            headers=self._client_wrapper.get_headers(),
            timeout=600,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Image, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def restart_container(
        self, *, variant_id: str
    ) -> typing.Dict[str, typing.Any]:
        """
        Restart docker container.

        Args:
        payload (RestartAppContainer) -- the required data (app_name and variant_name)

        Parameters:
            - variant_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.restart_container(variant_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                "containers/restart_container",
            ),
            json=jsonable_encoder({"variant_id": variant_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def container_templates(self) -> ContainerTemplatesResponse:
        """
        Returns a list of templates available for creating new containers.

        Parameters:
        stoken_session (SessionContainer): The session container for the user.

        Returns:

        Union[List[Template], str]: A list of templates or an error message.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/templates"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ContainerTemplatesResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def construct_app_container_url(
        self,
        *,
        base_id: typing.Optional[str] = None,
        variant_id: typing.Optional[str] = None,
    ) -> Uri:
        """
        Constructs the URL for an app container based on the provided base_id or variant_id.

        Args:
        base_id (Optional[str]): The ID of the base to use for the app container.
        variant_id (Optional[str]): The ID of the variant to use for the app container.
        stoken_session (SessionContainer): The session container for the user.

        Returns:
        URI: The URI for the app container.

        Raises:
        HTTPException: If the base or variant cannot be found or the user does not have access.

        Parameters:
            - base_id: typing.Optional[str].

            - variant_id: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.construct_app_container_url()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "containers/container_url"
            ),
            params=remove_none_from_dict(
                {"base_id": base_id, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uri, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def deploy_to_environment(
        self, *, environment_name: str, variant_id: str
    ) -> typing.Any:
        """
        Deploys a given variant to an environment

        Args:
        environment_name: Name of the environment to deploy to.
        variant_id: variant id to deploy.
        stoken_session: . Defaults to Depends(verify_session()).

        Raises:
        HTTPException: If the deployment fails.

        Parameters:
            - environment_name: str.

            - variant_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.deploy_to_environment(environment_name="string", variant_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "environments/deploy"
            ),
            json=jsonable_encoder(
                {"environment_name": environment_name, "variant_id": variant_id}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_trace(
        self,
        *,
        app_id: typing.Optional[str] = OMIT,
        variant_id: typing.Optional[str] = OMIT,
        cost: typing.Optional[float] = OMIT,
        latency: float,
        status: str,
        token_consumption: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
        start_time: dt.datetime,
        end_time: dt.datetime,
        spans: typing.List[str],
    ) -> str:
        """
        Parameters:
            - app_id: typing.Optional[str].

            - variant_id: typing.Optional[str].

            - cost: typing.Optional[float].

            - latency: float.

            - status: str.

            - token_consumption: typing.Optional[int].

            - tags: typing.Optional[typing.List[str]].

            - start_time: dt.datetime.

            - end_time: dt.datetime.

            - spans: typing.List[str].
        ---
        import datetime

        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_trace(
            latency=1.1,
            status="string",
            start_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
            end_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
            spans=[],
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "latency": latency,
            "status": status,
            "start_time": start_time,
            "end_time": end_time,
            "spans": spans,
        }
        if app_id is not OMIT:
            _request["app_id"] = app_id
        if variant_id is not OMIT:
            _request["variant_id"] = variant_id
        if cost is not OMIT:
            _request["cost"] = cost
        if token_consumption is not OMIT:
            _request["token_consumption"] = token_consumption
        if tags is not OMIT:
            _request["tags"] = tags
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/traces"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_traces(self, app_id: str, variant_id: str) -> typing.List[Trace]:
        """
        Parameters:
            - app_id: str.

            - variant_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_traces(app_id="string", variant_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{app_id}/{variant_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Trace], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_single_trace(self, trace_id: str) -> Trace:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_single_trace(trace_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Trace, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_trace_status(self, trace_id: str, *, status: str) -> bool:
        """
        Parameters:
            - trace_id: str.

            - status: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_trace_status(trace_id="string", status="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/traces/{trace_id}",
            ),
            json=jsonable_encoder({"status": status}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(bool, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_span(
        self,
        *,
        parent_span_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        event_name: str,
        event_type: typing.Optional[str] = OMIT,
        start_time: dt.datetime,
        duration: typing.Optional[int] = OMIT,
        status: str,
        end_time: dt.datetime,
        inputs: typing.Optional[typing.List[str]] = OMIT,
        outputs: typing.Optional[typing.List[str]] = OMIT,
        prompt_template: typing.Optional[str] = OMIT,
        tokens_input: typing.Optional[int] = OMIT,
        tokens_output: typing.Optional[int] = OMIT,
        token_total: typing.Optional[int] = OMIT,
        cost: typing.Optional[float] = OMIT,
        tags: typing.Optional[typing.List[str]] = OMIT,
    ) -> str:
        """
        Parameters:
            - parent_span_id: typing.Optional[str].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].

            - event_name: str.

            - event_type: typing.Optional[str].

            - start_time: dt.datetime.

            - duration: typing.Optional[int].

            - status: str.

            - end_time: dt.datetime.

            - inputs: typing.Optional[typing.List[str]].

            - outputs: typing.Optional[typing.List[str]].

            - prompt_template: typing.Optional[str].

            - tokens_input: typing.Optional[int].

            - tokens_output: typing.Optional[int].

            - token_total: typing.Optional[int].

            - cost: typing.Optional[float].

            - tags: typing.Optional[typing.List[str]].
        ---
        import datetime

        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_span(
            event_name="string",
            start_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
            status="string",
            end_time=datetime.datetime.fromisoformat("2024-01-15 09:30:00+00:00"),
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "event_name": event_name,
            "start_time": start_time,
            "status": status,
            "end_time": end_time,
        }
        if parent_span_id is not OMIT:
            _request["parent_span_id"] = parent_span_id
        if meta is not OMIT:
            _request["meta"] = meta
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if duration is not OMIT:
            _request["duration"] = duration
        if inputs is not OMIT:
            _request["inputs"] = inputs
        if outputs is not OMIT:
            _request["outputs"] = outputs
        if prompt_template is not OMIT:
            _request["prompt_template"] = prompt_template
        if tokens_input is not OMIT:
            _request["tokens_input"] = tokens_input
        if tokens_output is not OMIT:
            _request["tokens_output"] = tokens_output
        if token_total is not OMIT:
            _request["token_total"] = token_total
        if cost is not OMIT:
            _request["cost"] = cost
        if tags is not OMIT:
            _request["tags"] = tags
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "observability/spans"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_spans_of_trace(self, trace_id: str) -> typing.List[Span]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_spans_of_trace(trace_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/spans/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Span], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_feedbacks(self, trace_id: str) -> typing.List[Feedback]:
        """
        Parameters:
            - trace_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_feedbacks(trace_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Feedback], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_feedback(
        self,
        trace_id: str,
        *,
        feedback: typing.Optional[str] = OMIT,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> str:
        """
        Parameters:
            - trace_id: str.

            - feedback: typing.Optional[str].

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.create_feedback(trace_id="string")
        """
        _request: typing.Dict[str, typing.Any] = {}
        if feedback is not OMIT:
            _request["feedback"] = feedback
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_feedback(self, trace_id: str, feedback_id: str) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_feedback(trace_id="string", feedback_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_feedback(
        self,
        trace_id: str,
        feedback_id: str,
        *,
        feedback: str,
        score: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> Feedback:
        """
        Parameters:
            - trace_id: str.

            - feedback_id: str.

            - feedback: str.

            - score: typing.Optional[float].

            - meta: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.update_feedback(trace_id="string", feedback_id="string", feedback="string")
        """
        _request: typing.Dict[str, typing.Any] = {"feedback": feedback}
        if score is not OMIT:
            _request["score"] = score
        if meta is not OMIT:
            _request["meta"] = meta
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"observability/feedbacks/{trace_id}/{feedback_id}",
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Feedback, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_organizations(self) -> typing.List[Organization]:
        """
        Returns a list of organizations associated with the user's session.

        Args:
        stoken_session (SessionContainer): The user's session token.

        Returns:
        list[Organization]: A list of organizations associated with the user's session.

        Raises:
        HTTPException: If there is an error retrieving the organizations from the database.

        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_organizations()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Organization], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_own_org(self) -> OrganizationOutput:
        """
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_own_org()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "organizations/own"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OrganizationOutput, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_bases(
        self,
        *,
        app_id: typing.Optional[str] = None,
        base_name: typing.Optional[str] = None,
    ) -> typing.List[BaseOutput]:
        """
        Retrieve a list of bases filtered by app_id and base_name.

        Args:
        request (Request): The incoming request.
        app_id (Optional[str], optional): The ID of the app to filter by. Defaults to None.
        base_name (Optional[str], optional): The name of the base to filter by. Defaults to None.

        Returns:
        List[BaseOutput]: A list of BaseOutput objects representing the filtered bases.

        Raises:
        HTTPException: If there was an error retrieving the bases.

        Parameters:
            - app_id: typing.Optional[str].

            - base_name: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.list_bases()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "bases"),
            params=remove_none_from_dict({"app_id": app_id, "base_name": base_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[BaseOutput], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_config(
        self,
        *,
        base_id: str,
        config_name: typing.Optional[str] = None,
        environment_name: typing.Optional[str] = None,
    ) -> GetConfigReponse:
        """
        Parameters:
            - base_id: str.

            - config_name: typing.Optional[str].

            - environment_name: typing.Optional[str].
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.get_config(base_id="string")
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            params=remove_none_from_dict(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "environment_name": environment_name,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetConfigReponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def save_config(
        self,
        *,
        base_id: str,
        config_name: str,
        parameters: typing.Dict[str, typing.Any],
        overwrite: bool,
    ) -> typing.Any:
        """
        Parameters:
            - base_id: str.

            - config_name: str.

            - parameters: typing.Dict[str, typing.Any].

            - overwrite: bool.
        ---
        from agenta.client import AsyncAgentaApi

        client = AsyncAgentaApi(api_key="YOUR_API_KEY", base_url="https://yourhost.com/path/to/api")
        await client.save_config(
            base_id="string",
            config_name="string",
            parameters={"string": {"unknown": "string", "type": "unknown"}},
            overwrite=True,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "configs"),
            json=jsonable_encoder(
                {
                    "base_id": base_id,
                    "config_name": config_name,
                    "parameters": parameters,
                    "overwrite": overwrite,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
