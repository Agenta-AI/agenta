================================================================================
‚úÖ TAGS IMPLEMENTATION PLANNING - COMPLETE
================================================================================

Date: 2025-11-27
Location: /claude (OSS and EE)
Status: Ready for implementation

================================================================================
DELIVERABLES CREATED
================================================================================

üìã DOCUMENTATION (5 files created in /claude/)

1. README_TAGS.md ‚≠ê START HERE
   - Overview and navigation guide
   - Which document to read for what purpose
   - Quick reference and FAQ
   - ~5 minute read

2. TAGS_WORK_SUMMARY.txt (EXECUTIVE SUMMARY)
   - Complete overview of scope and approach
   - Entity mappings (9 kinds, 15 tables)
   - Work breakdown (7 tasks in 3 phases)
   - Schema design and trigger logic
   - File structure and effort estimates
   - ~8 minute read

3. TAGS_STARTER_GUIDE.md (IMPLEMENTATION GUIDE)
   - Step-by-step implementation for workflows (start small)
   - 5 clear implementation steps
   - Testing scenarios
   - Expansion strategy to other entities
   - Migration template
   - ~10 minute read

4. TAGS_SQL_EXAMPLES.md (DEVELOPER REFERENCE)
   - Complete, ready-to-use SQL code
   - Trigger function exact syntax
   - All 15 trigger statements
   - Test scenarios with queries
   - Full Alembic migration template
   - ~8 minute reference

5. TAGS_IMPLEMENTATION_PLAN.md (DETAILED PLAN)
   - Full technical specifications
   - All 7 tasks broken down in detail
   - Phase-by-phase approach
   - Database schema with explanations
   - EE considerations
   - ~15 minute read

6. TAGS_ARCHITECTURE_DIAGRAM.txt (VISUAL REFERENCE)
   - ASCII diagrams of system architecture
   - Entity ‚Üí Trigger ‚Üí Tags table flow
   - Manual edit scenario walkthrough
   - Performance characteristics
   - Scaling strategy
   - Key numbers and indexes

================================================================================
KEY FINDINGS
================================================================================

‚úÖ GOOD NEWS:
  ‚Ä¢ All entity tables ALREADY have tags column (inherit TagsDBA mixin)
  ‚Ä¢ No entity schema changes needed
  ‚Ä¢ Tags are already stored in JSONB with dot-notation keys
  ‚Ä¢ Trigger pattern is simple and reusable across all 15 tables
  ‚Ä¢ Single trigger function handles all 9 entity kinds

üéØ SCOPE:
  ‚Ä¢ 9 entity kinds: testset, workflow, query, evaluation_run, evaluation_scenario,
                    evaluation_result, evaluation_metrics, evaluation_queue, blob
  ‚Ä¢ 15 total tables (3 git-based entities with artifact/variant/revision each)
  ‚Ä¢ 15 triggers (one per table, same function)
  ‚Ä¢ 1 shared tags registry table
  ‚Ä¢ 3 core components: DB table, trigger function, API endpoint

üìä EFFORT ESTIMATE:
  ‚Ä¢ Phase 1 (Database): 2 hours (4 migration files)
  ‚Ä¢ Phase 2 (API): 45 minutes (1 module with routes)
  ‚Ä¢ Phase 3 (Utilities): 20 minutes (2 functions)
  ‚Ä¢ Total: ~3.25 hours (implementation, testing separate)

================================================================================
RECOMMENDED APPROACH
================================================================================

START SMALL: Implement Workflows First

Why workflows?
  ‚úì 3 tables = good sample size
  ‚úì Same pattern applies to all entities
  ‚úì Easy to validate before scaling
  ‚úì Can expand incrementally

Implementation order:
  1. Create 4 migration files for workflows
     - Create tags table
     - Create trigger function
     - Attach 3 workflow triggers
     - Backfill from existing workflows
  2. Test with workflows in isolation
  3. Create tags API endpoint
  4. Expand to remaining entities (testsets, queries, evaluations, blobs)

Benefits:
  ‚úì Fast initial validation (can test in 2-3 hours)
  ‚úì Low risk (isolated to workflows first)
  ‚úì Easy to scale (copy-paste pattern to other entities)
  ‚úì Team can review and approve before full rollout

================================================================================
NEXT STEPS (IMMEDIATE ACTIONS)
================================================================================

1. READ (15 minutes)
   ‚Üí Start with README_TAGS.md to understand structure
   ‚Üí Read TAGS_WORK_SUMMARY.txt for full picture
   ‚Üí Skim TAGS_STARTER_GUIDE.md for implementation approach

2. REVIEW (30 minutes)
   ‚Üí Check entity tables match your codebase
   ‚Üí Verify workflow tables exist at expected location
   ‚Üí Confirm migration directory structure

3. CREATE MIGRATION FILES (90 minutes)
   ‚Üí Use TAGS_SQL_EXAMPLES.md as template
   ‚Üí Create 4 files:
     a) Add tags table
     b) Add trigger function + workflow triggers
     c) Backfill tags from workflows
   ‚Üí Verify migration IDs don't conflict

4. TEST (60 minutes)
   ‚Üí Run migrations
   ‚Üí Insert/update workflow with tags
   ‚Üí Verify tags table populated
   ‚Üí Test API endpoint (if implemented)

5. EXPAND (120 minutes per entity group)
   ‚Üí Add testsets (same pattern as workflows)
   ‚Üí Add queries (same pattern)
   ‚Üí Add evaluations (5 tables, same pattern)
   ‚Üí Add blobs (1 table, same pattern)

================================================================================
IMPLEMENTATION CHECKLIST
================================================================================

PREPARATION:
  ‚òê Review README_TAGS.md (understand overview)
  ‚òê Review TAGS_WORK_SUMMARY.txt (understand scope)
  ‚òê Review TAGS_STARTER_GUIDE.md (understand approach)
  ‚òê Verify entity tables exist in /claude/api/oss/src/dbs/

WORKFLOWS:
  ‚òê Create migration: add tags table
  ‚òê Create migration: add trigger function + workflow triggers
  ‚òê Create migration: backfill from workflows
  ‚òê Test: Run migrations successfully
  ‚òê Test: Insert workflow with tags, verify tags table
  ‚òê Test: Update workflow tags, verify trigger fired
  ‚òê Test: Delete key from tags, update entity, verify key recreated

API ENDPOINTS:
  ‚òê Create /apis/fastapi/tags/ module
  ‚òê Create models.py with TagKeyResponse DTO
  ‚òê Create router.py with GET /projects/{id}/tags endpoint
  ‚òê Test: API returns correct keys for kind

UTILITIES:
  ‚òê Create /core/tags/utils.py
  ‚òê Implement flatten() function
  ‚òê Implement unflatten() function
  ‚òê Test: flatten/unflatten round-trip

EXPANSION (OPTIONAL):
  ‚òê Add testsets triggers (copy-paste workflow pattern)
  ‚òê Add queries triggers (copy-paste workflow pattern)
  ‚òê Add evaluations triggers (5 kinds, same pattern)
  ‚òê Add blobs trigger (same pattern)
  ‚òê Backfill all remaining entities

INTEGRATION:
  ‚òê Write integration tests
  ‚òê Update API documentation
  ‚òê Create user guide for tags feature

================================================================================
FILES TO CREATE/MODIFY
================================================================================

NEW FILES TO CREATE:
‚úèÔ∏è  /claude/api/oss/databases/postgres/migrations/core/versions/
    - 0001_add_tags_table.py
    - 0002_add_tags_trigger_and_workflow_triggers.py
    - 0003_backfill_tags_from_workflows.py

‚úèÔ∏è  /claude/api/oss/src/apis/fastapi/tags/
    - __init__.py
    - models.py
    - router.py

‚úèÔ∏è  /claude/api/oss/src/core/tags/
    - __init__.py
    - utils.py

POSSIBLY MODIFY:
  ‚Ä¢ /claude/api/oss/src/apis/fastapi/__init__.py (register tags router)
  ‚Ä¢ /claude/api/oss/src/main.py (or main FastAPI app setup)

FILES TO REFERENCE (READ-ONLY):
  ‚Ä¢ /claude/api/oss/src/dbs/postgres/workflows/dbes.py (verify tables)
  ‚Ä¢ /claude/api/oss/src/dbs/postgres/shared/dbas.py (TagsDBA definition)
  ‚Ä¢ /claude/api/oss/databases/postgres/migrations/core/versions/ (migration examples)

================================================================================
KEY DOCUMENTS
================================================================================

Design Specification:
  ‚Üí /sandbox/architecture/tags.initial.specs.md (source of truth)

Planning Documents (in /claude/):
  ‚Üí README_TAGS.md (navigation guide)
  ‚Üí TAGS_WORK_SUMMARY.txt (executive overview)
  ‚Üí TAGS_STARTER_GUIDE.md (how to implement)
  ‚Üí TAGS_SQL_EXAMPLES.md (code examples)
  ‚Üí TAGS_IMPLEMENTATION_PLAN.md (detailed plan)
  ‚Üí TAGS_ARCHITECTURE_DIAGRAM.txt (visual reference)
  ‚Üí PLANNING_COMPLETE.txt (this file)

================================================================================
KEY NUMBERS
================================================================================

Entity Kinds:           9
Workflow-related Kinds: 3 (testset, workflow, query with 3 tables each)
Single-table Kinds:     5 (evaluation_run/scenario/result/metrics/queue)
Other Kinds:            1 (blob)

Total Tables:           15 (3+3+3+1+1+1+1+1+1)
Triggers:               15 (one per table)
Trigger Function:       1 (reused across all)
Tags Registry Table:    1 (shared, scoped by project_id + kind)

Typical tag keys per project:           50-500
Typical tag keys per entity kind:       5-20
Typical entries in tags table (large project): ~100,000
Index operations:       O(log n) for lookups, ~1ms typical

================================================================================
DESIGN PRINCIPLES (RECAP)
================================================================================

1. FLAT DOT-NOTATION: Tags stored as {"env": "prod", "owner.name": "Juan"}
   ‚Üí Not nested: {"owner": {"name": "Juan"}}

2. REGISTRY PATTERN: Separate tags table (project_id, kind, key)
   ‚Üí For autocomplete queries
   ‚Üí Values stay in entity.tags

3. TRIGGER-BASED SYNC: PostgreSQL triggers auto-maintain the registry
   ‚Üí On entity INSERT/UPDATE: extract tag keys and insert into registry
   ‚Üí ON CONFLICT DO NOTHING: preserves manual edits

4. MANUAL EDIT SAFETY: Users can edit/delete keys in tags table
   ‚Üí Deleted keys re-created if entity still uses them
   ‚Üí Edits are preserved

5. NO VALIDATION: Tags assumed already in dot-notation
   ‚Üí Flatten/unflatten helpers available but not required

================================================================================
SUCCESS CRITERIA
================================================================================

‚úÖ Workflows complete:
   ‚Ä¢ migrations run without error
   ‚Ä¢ tags table populated from existing workflows
   ‚Ä¢ triggers fire on workflow INSERT/UPDATE
   ‚Ä¢ manual edits to tags table are preserved

‚úÖ API endpoints working:
   ‚Ä¢ GET /projects/{id}/tags?kind=workflow returns list of keys
   ‚Ä¢ Response is correct format and sorted

‚úÖ Utilities available:
   ‚Ä¢ flatten() and unflatten() work correctly
   ‚Ä¢ Round-trip conversion preserves data

‚úÖ Expansion successful:
   ‚Ä¢ Same pattern successfully applied to 6 more entity kinds
   ‚Ä¢ All triggers fire correctly
   ‚Ä¢ Backfill completes without errors

‚úÖ Integration complete:
   ‚Ä¢ Tests pass
   ‚Ä¢ Documentation updated
   ‚Ä¢ Feature ready for production

================================================================================
ESTIMATED TIMELINE
================================================================================

Workflows Only:
  ‚Ä¢ Planning: COMPLETE ‚úÖ
  ‚Ä¢ Implementation: ~2-3 hours
  ‚Ä¢ Testing: ~1 hour
  ‚Ä¢ Review/Iteration: ~1 hour
  Total: ~4-5 hours

Full Implementation (All 9 Kinds):
  ‚Ä¢ Workflows: ~4-5 hours
  ‚Ä¢ Testsets + Queries: ~2 hours (copy-paste, simpler)
  ‚Ä¢ Evaluations + Blobs: ~1 hour (single table each)
  ‚Ä¢ API + Utilities: ~2 hours (independent of DB count)
  ‚Ä¢ Testing & Integration: ~3-4 hours
  Total: ~12-16 hours

================================================================================
QUESTIONS ANSWERED
================================================================================

Q: Are all entities ready with tags column?
A: ‚úÖ Yes, all tables already inherit TagsDBA mixin

Q: Do I need to modify existing entity tables?
A: ‚ùå No, tags column already exists

Q: Will triggers affect existing code?
A: ‚ùå No, triggers only read and populate new tags table

Q: What if tags are not in dot-notation?
A: Specs assume they are. Flatten/unflatten utilities provided for future.

Q: Can users edit the tags table?
A: ‚úÖ Yes, they can edit/delete keys. Deleted keys re-added if entity still uses them.

Q: Should I implement all entities at once?
A: üîÑ No, start with workflows, validate, then expand

Q: What about EE?
A: üîÑ EE inherits from OSS. Apply same migrations, possibly separately if EE has own migration chain.

================================================================================
CONTACTS & REFERENCES
================================================================================

Source Documents:
  ‚Ä¢ Design Spec: /sandbox/architecture/tags.initial.specs.md
  ‚Ä¢ Code Location: /claude/api/oss/src/dbs/postgres/

Planning Documents:
  ‚Ä¢ All in /claude/ directory (this planning session output)

Entity Definitions:
  ‚Ä¢ Workflows: /claude/api/oss/src/dbs/postgres/workflows/dbes.py
  ‚Ä¢ Testsets: /claude/api/oss/src/dbs/postgres/testsets/dbes.py
  ‚Ä¢ Queries: /claude/api/oss/src/dbs/postgres/queries/dbes.py
  ‚Ä¢ Evaluations: /claude/api/oss/src/dbs/postgres/evaluations/dbes.py
  ‚Ä¢ Shared: /claude/api/oss/src/dbs/postgres/shared/dbas.py (TagsDBA)

Migrations:
  ‚Ä¢ Location: /claude/api/oss/databases/postgres/migrations/core/versions/
  ‚Ä¢ Examples: See TAGS_SQL_EXAMPLES.md

================================================================================
FINAL NOTES
================================================================================

‚úÖ Planning is COMPLETE - All documents created and ready
‚úÖ Implementation is STRAIGHTFORWARD - Clear step-by-step approach
‚úÖ Design is PROVEN - Pattern used successfully in many systems
‚úÖ Scope is CLEAR - 9 entities, 15 tables, 1 registry table
‚úÖ Risk is LOW - Changes are additive, no existing table modifications

Ready to proceed with implementation!

Next: Review documents, create migration files, test with workflows.

================================================================================
END OF PLANNING SUMMARY
================================================================================
