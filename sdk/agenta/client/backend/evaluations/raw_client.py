# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.evaluation import Evaluation
from ..types.evaluation_metrics_create import EvaluationMetricsCreate
from ..types.evaluation_metrics_edit import EvaluationMetricsEdit
from ..types.evaluation_metrics_ids_response import EvaluationMetricsIdsResponse
from ..types.evaluation_metrics_query import EvaluationMetricsQuery
from ..types.evaluation_metrics_refresh import EvaluationMetricsRefresh
from ..types.evaluation_metrics_response import EvaluationMetricsResponse
from ..types.evaluation_queue_create import EvaluationQueueCreate
from ..types.evaluation_queue_edit import EvaluationQueueEdit
from ..types.evaluation_queue_id_response import EvaluationQueueIdResponse
from ..types.evaluation_queue_ids_response import EvaluationQueueIdsResponse
from ..types.evaluation_queue_query import EvaluationQueueQuery
from ..types.evaluation_queue_response import EvaluationQueueResponse
from ..types.evaluation_queue_scenario_ids_response import (
    EvaluationQueueScenarioIdsResponse,
)
from ..types.evaluation_queues_response import EvaluationQueuesResponse
from ..types.evaluation_result_create import EvaluationResultCreate
from ..types.evaluation_result_edit import EvaluationResultEdit
from ..types.evaluation_result_id_response import EvaluationResultIdResponse
from ..types.evaluation_result_ids_response import EvaluationResultIdsResponse
from ..types.evaluation_result_query import EvaluationResultQuery
from ..types.evaluation_result_response import EvaluationResultResponse
from ..types.evaluation_results_response import EvaluationResultsResponse
from ..types.evaluation_run_create import EvaluationRunCreate
from ..types.evaluation_run_edit import EvaluationRunEdit
from ..types.evaluation_run_id_response import EvaluationRunIdResponse
from ..types.evaluation_run_ids_response import EvaluationRunIdsResponse
from ..types.evaluation_run_query import EvaluationRunQuery
from ..types.evaluation_run_response import EvaluationRunResponse
from ..types.evaluation_runs_response import EvaluationRunsResponse
from ..types.evaluation_scenario_create import EvaluationScenarioCreate
from ..types.evaluation_scenario_edit import EvaluationScenarioEdit
from ..types.evaluation_scenario_id_response import EvaluationScenarioIdResponse
from ..types.evaluation_scenario_ids_response import EvaluationScenarioIdsResponse
from ..types.evaluation_scenario_query import EvaluationScenarioQuery
from ..types.evaluation_scenario_response import EvaluationScenarioResponse
from ..types.evaluation_scenarios_response import EvaluationScenariosResponse
from ..types.evaluation_status import EvaluationStatus
from ..types.http_validation_error import HttpValidationError
from ..types.llm_run_rate_limit import LlmRunRateLimit
from ..types.oss_src_models_api_evaluation_model_evaluation_scenario import (
    OssSrcModelsApiEvaluationModelEvaluationScenario,
)
from ..types.simple_evaluation_create import SimpleEvaluationCreate
from ..types.simple_evaluation_edit import SimpleEvaluationEdit
from ..types.simple_evaluation_id_response import SimpleEvaluationIdResponse
from ..types.simple_evaluation_query import SimpleEvaluationQuery
from ..types.simple_evaluation_response import SimpleEvaluationResponse
from ..types.simple_evaluations_response import SimpleEvaluationsResponse
from ..types.windowing import Windowing

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEvaluationsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def refresh_runs(
        self,
        *,
        trigger_interval: typing.Optional[int] = None,
        trigger_datetime: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Any]:
        """
        Parameters
        ----------
        trigger_interval : typing.Optional[int]

        trigger_datetime : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Any]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/evaluations/runs/refresh",
            method="POST",
            params={
                "trigger_interval": trigger_interval,
                "trigger_datetime": serialize_datetime(trigger_datetime)
                if trigger_datetime is not None
                else None,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_runs(
        self,
        *,
        runs: typing.Sequence[EvaluationRunCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        runs : typing.Sequence[EvaluationRunCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/",
            method="POST",
            json={
                "runs": convert_and_respect_annotation_metadata(
                    object_=runs,
                    annotation=typing.Sequence[EvaluationRunCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_runs(
        self,
        *,
        run_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunIdsResponse]:
        """
        Parameters
        ----------
        run_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunIdsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/",
            method="DELETE",
            json={
                "run_ids": run_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunIdsResponse,
                    parse_obj_as(
                        type_=EvaluationRunIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_runs(
        self,
        *,
        runs: typing.Sequence[EvaluationRunEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        runs : typing.Sequence[EvaluationRunEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/",
            method="PATCH",
            json={
                "runs": convert_and_respect_annotation_metadata(
                    object_=runs,
                    annotation=typing.Sequence[EvaluationRunEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def query_runs(
        self,
        *,
        run: typing.Optional[EvaluationRunQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        run : typing.Optional[EvaluationRunQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/query",
            method="POST",
            json={
                "run": convert_and_respect_annotation_metadata(
                    object_=run,
                    annotation=typing.Optional[EvaluationRunQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def close_runs(
        self,
        *,
        run_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        run_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/close",
            method="POST",
            json={
                "run_ids": run_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def open_runs(
        self,
        *,
        run_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        run_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/open",
            method="POST",
            json={
                "run_ids": run_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_run(
        self, run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_run(
        self, run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationRunIdResponse]:
        """
        Parameters
        ----------
        run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunIdResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunIdResponse,
                    parse_obj_as(
                        type_=EvaluationRunIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_run(
        self,
        run_id: str,
        *,
        run: EvaluationRunEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        run : EvaluationRunEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}",
            method="PATCH",
            json={
                "run": convert_and_respect_annotation_metadata(
                    object_=run, annotation=EvaluationRunEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def close_run(
        self,
        run_id: str,
        status: typing.Optional[EvaluationStatus],
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        status : typing.Optional[EvaluationStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}/close/{jsonable_encoder(status)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def open_run(
        self, run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}/open",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_scenarios(
        self,
        *,
        scenarios: typing.Sequence[EvaluationScenarioCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenariosResponse]:
        """
        Parameters
        ----------
        scenarios : typing.Sequence[EvaluationScenarioCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenariosResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/",
            method="POST",
            json={
                "scenarios": convert_and_respect_annotation_metadata(
                    object_=scenarios,
                    annotation=typing.Sequence[EvaluationScenarioCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenariosResponse,
                    parse_obj_as(
                        type_=EvaluationScenariosResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_scenarios(
        self,
        *,
        scenario_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenarioIdsResponse]:
        """
        Parameters
        ----------
        scenario_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenarioIdsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/",
            method="DELETE",
            json={
                "scenario_ids": scenario_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioIdsResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_scenarios(
        self,
        *,
        scenarios: typing.Sequence[EvaluationScenarioEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenariosResponse]:
        """
        Parameters
        ----------
        scenarios : typing.Sequence[EvaluationScenarioEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenariosResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/",
            method="PATCH",
            json={
                "scenarios": convert_and_respect_annotation_metadata(
                    object_=scenarios,
                    annotation=typing.Sequence[EvaluationScenarioEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenariosResponse,
                    parse_obj_as(
                        type_=EvaluationScenariosResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def query_scenarios(
        self,
        *,
        scenario: typing.Optional[EvaluationScenarioQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenariosResponse]:
        """
        Parameters
        ----------
        scenario : typing.Optional[EvaluationScenarioQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenariosResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/query",
            method="POST",
            json={
                "scenario": convert_and_respect_annotation_metadata(
                    object_=scenario,
                    annotation=typing.Optional[EvaluationScenarioQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenariosResponse,
                    parse_obj_as(
                        type_=EvaluationScenariosResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_scenario(
        self,
        scenario_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenarioResponse]:
        """
        Parameters
        ----------
        scenario_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenarioResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/scenarios/{jsonable_encoder(scenario_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_scenario(
        self,
        scenario_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenarioIdResponse]:
        """
        Parameters
        ----------
        scenario_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenarioIdResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/scenarios/{jsonable_encoder(scenario_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioIdResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_scenario(
        self,
        scenario_id: str,
        *,
        scenario: EvaluationScenarioEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationScenarioResponse]:
        """
        Parameters
        ----------
        scenario_id : str

        scenario : EvaluationScenarioEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationScenarioResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/scenarios/{jsonable_encoder(scenario_id)}",
            method="PATCH",
            json={
                "scenario": convert_and_respect_annotation_metadata(
                    object_=scenario,
                    annotation=EvaluationScenarioEdit,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_results(
        self,
        *,
        results: typing.Sequence[EvaluationResultCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationResultsResponse]:
        """
        Parameters
        ----------
        results : typing.Sequence[EvaluationResultCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/",
            method="POST",
            json={
                "results": convert_and_respect_annotation_metadata(
                    object_=results,
                    annotation=typing.Sequence[EvaluationResultCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultsResponse,
                    parse_obj_as(
                        type_=EvaluationResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_results(
        self,
        *,
        result_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationResultIdsResponse]:
        """
        Parameters
        ----------
        result_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultIdsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/",
            method="DELETE",
            json={
                "result_ids": result_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultIdsResponse,
                    parse_obj_as(
                        type_=EvaluationResultIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_results(
        self,
        *,
        results: typing.Sequence[EvaluationResultEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationResultsResponse]:
        """
        Parameters
        ----------
        results : typing.Sequence[EvaluationResultEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/",
            method="PATCH",
            json={
                "results": convert_and_respect_annotation_metadata(
                    object_=results,
                    annotation=typing.Sequence[EvaluationResultEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultsResponse,
                    parse_obj_as(
                        type_=EvaluationResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def query_results(
        self,
        *,
        result: typing.Optional[EvaluationResultQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationResultsResponse]:
        """
        Parameters
        ----------
        result : typing.Optional[EvaluationResultQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/query",
            method="POST",
            json={
                "result": convert_and_respect_annotation_metadata(
                    object_=result,
                    annotation=typing.Optional[EvaluationResultQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultsResponse,
                    parse_obj_as(
                        type_=EvaluationResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_result(
        self, result_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationResultResponse]:
        """
        Parameters
        ----------
        result_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/results/{jsonable_encoder(result_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultResponse,
                    parse_obj_as(
                        type_=EvaluationResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_result(
        self, result_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationResultIdResponse]:
        """
        Parameters
        ----------
        result_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultIdResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/results/{jsonable_encoder(result_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultIdResponse,
                    parse_obj_as(
                        type_=EvaluationResultIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_result(
        self,
        result_id: str,
        *,
        result: EvaluationResultEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationResultResponse]:
        """
        Parameters
        ----------
        result_id : str

        result : EvaluationResultEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationResultResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/results/{jsonable_encoder(result_id)}",
            method="PATCH",
            json={
                "result": convert_and_respect_annotation_metadata(
                    object_=result, annotation=EvaluationResultEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultResponse,
                    parse_obj_as(
                        type_=EvaluationResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def refresh_metrics(
        self,
        *,
        metrics: EvaluationMetricsRefresh,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : EvaluationMetricsRefresh

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/refresh",
            method="POST",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=EvaluationMetricsRefresh,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_metrics(
        self,
        *,
        metrics: typing.Sequence[EvaluationMetricsCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : typing.Sequence[EvaluationMetricsCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/",
            method="POST",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=typing.Sequence[EvaluationMetricsCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_metrics(
        self,
        *,
        metrics_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationMetricsIdsResponse]:
        """
        Parameters
        ----------
        metrics_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationMetricsIdsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/",
            method="DELETE",
            json={
                "metrics_ids": metrics_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsIdsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_metrics(
        self,
        *,
        metrics: typing.Sequence[EvaluationMetricsEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : typing.Sequence[EvaluationMetricsEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/",
            method="PATCH",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=typing.Sequence[EvaluationMetricsEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def query_metrics(
        self,
        *,
        metrics: typing.Optional[EvaluationMetricsQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : typing.Optional[EvaluationMetricsQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/query",
            method="POST",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=typing.Optional[EvaluationMetricsQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_queues(
        self,
        *,
        queues: typing.Sequence[EvaluationQueueCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationQueuesResponse]:
        """
        Parameters
        ----------
        queues : typing.Sequence[EvaluationQueueCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueuesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/",
            method="POST",
            json={
                "queues": convert_and_respect_annotation_metadata(
                    object_=queues,
                    annotation=typing.Sequence[EvaluationQueueCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueuesResponse,
                    parse_obj_as(
                        type_=EvaluationQueuesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_queues(
        self,
        *,
        queue_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationQueueIdsResponse]:
        """
        Parameters
        ----------
        queue_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueueIdsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/",
            method="DELETE",
            json={
                "queue_ids": queue_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueIdsResponse,
                    parse_obj_as(
                        type_=EvaluationQueueIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_queues(
        self,
        *,
        queues: typing.Sequence[EvaluationQueueEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationQueuesResponse]:
        """
        Parameters
        ----------
        queues : typing.Sequence[EvaluationQueueEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueuesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/",
            method="PATCH",
            json={
                "queues": convert_and_respect_annotation_metadata(
                    object_=queues,
                    annotation=typing.Sequence[EvaluationQueueEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueuesResponse,
                    parse_obj_as(
                        type_=EvaluationQueuesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def query_queues(
        self,
        *,
        queue: typing.Optional[EvaluationQueueQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationQueuesResponse]:
        """
        Parameters
        ----------
        queue : typing.Optional[EvaluationQueueQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueuesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/query",
            method="POST",
            json={
                "queue": convert_and_respect_annotation_metadata(
                    object_=queue,
                    annotation=typing.Optional[EvaluationQueueQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueuesResponse,
                    parse_obj_as(
                        type_=EvaluationQueuesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_queue(
        self, queue_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationQueueResponse]:
        """
        Parameters
        ----------
        queue_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueueResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueResponse,
                    parse_obj_as(
                        type_=EvaluationQueueResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_queue(
        self, queue_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluationQueueIdResponse]:
        """
        Parameters
        ----------
        queue_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueueIdResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueIdResponse,
                    parse_obj_as(
                        type_=EvaluationQueueIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_queue(
        self,
        queue_id: str,
        *,
        queue: EvaluationQueueEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationQueueResponse]:
        """
        Parameters
        ----------
        queue_id : str

        queue : EvaluationQueueEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueueResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}",
            method="PATCH",
            json={
                "queue": convert_and_respect_annotation_metadata(
                    object_=queue, annotation=EvaluationQueueEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueResponse,
                    parse_obj_as(
                        type_=EvaluationQueueResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_queue_scenarios(
        self,
        queue_id: str,
        *,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationQueueScenarioIdsResponse]:
        """
        Parameters
        ----------
        queue_id : str

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationQueueScenarioIdsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}/scenarios",
            method="GET",
            params={
                "user_id": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueScenarioIdsResponse,
                    parse_obj_as(
                        type_=EvaluationQueueScenarioIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_evaluation(
        self,
        *,
        evaluation: SimpleEvaluationCreate,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation : SimpleEvaluationCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/simple/evaluations/",
            method="POST",
            json={
                "evaluation": convert_and_respect_annotation_metadata(
                    object_=evaluation,
                    annotation=SimpleEvaluationCreate,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationIdResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationIdResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationIdResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_evaluation(
        self,
        evaluation_id: str,
        *,
        evaluation: SimpleEvaluationEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        evaluation : SimpleEvaluationEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}",
            method="PATCH",
            json={
                "evaluation": convert_and_respect_annotation_metadata(
                    object_=evaluation,
                    annotation=SimpleEvaluationEdit,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def query_evaluations(
        self,
        *,
        evaluation: typing.Optional[SimpleEvaluationQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationsResponse]:
        """
        Parameters
        ----------
        evaluation : typing.Optional[SimpleEvaluationQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/simple/evaluations/query",
            method="POST",
            json={
                "evaluation": convert_and_respect_annotation_metadata(
                    object_=evaluation,
                    annotation=typing.Optional[SimpleEvaluationQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationsResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def start_simple_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/start",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def stop_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/stop",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def close_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/close",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def open_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/open",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_evaluation_ids(
        self,
        *,
        resource_type: str,
        resource_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[str]]:
        """
        Fetches evaluation ids for a given resource type and id.

        Arguments:
            app_id (str): The ID of the app for which to fetch evaluations.
            resource_type (str): The type of resource for which to fetch evaluations.
            resource_ids List[ObjectId]: The IDs of resource for which to fetch evaluations.

        Raises:
            HTTPException: If the resource_type is invalid or access is denied.

        Returns:
            List[str]: A list of evaluation ids.

        Parameters
        ----------
        resource_type : str

        resource_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[str]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluations/by_resource",
            method="GET",
            params={
                "resource_type": resource_type,
                "resource_ids": resource_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_evaluation_status(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Any]:
        """
        Fetches the status of the evaluation.

        Args:
            evaluation_id (str): the evaluation id
            request (Request): the request object

        Returns:
            (str): the evaluation status

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Any]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_legacy_evaluation_results(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Any]:
        """
        Fetches the results of the evaluation

        Args:
            evaluation_id (str): the evaluation id
            request (Request): the request object

        Returns:
            _type_: _description_

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Any]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}/results",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_legacy_evaluation_scenarios(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[OssSrcModelsApiEvaluationModelEvaluationScenario]]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
            evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
            HTTPException: If the evaluation is not found or access is denied.

        Returns:
            List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[OssSrcModelsApiEvaluationModelEvaluationScenario]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}/evaluation_scenarios",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[OssSrcModelsApiEvaluationModelEvaluationScenario],
                    parse_obj_as(
                        type_=typing.List[
                            OssSrcModelsApiEvaluationModelEvaluationScenario
                        ],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_legacy_evaluations(
        self, *, app_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[Evaluation]]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
            app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
            List[Evaluation]: A list of evaluations.

        Parameters
        ----------
        app_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Evaluation]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluations",
            method="GET",
            params={
                "app_id": app_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Evaluation],
                    parse_obj_as(
                        type_=typing.List[Evaluation],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_legacy_evaluations(
        self,
        *,
        evaluations_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[str]]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters
        ----------
        evaluations_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[str]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluations",
            method="DELETE",
            json={
                "evaluations_ids": evaluations_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_legacy_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Evaluation]:
        """
        Fetches a single evaluation based on its ID.

        Args:
            evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
            Evaluation: The fetched evaluation.

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Evaluation]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Evaluation,
                    parse_obj_as(
                        type_=Evaluation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def fetch_legacy_evaluation_scenarios_comparison_results(
        self,
        *,
        evaluations_ids: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Any]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
            evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
            HTTPException: If the evaluation is not found or access is denied.

        Returns:
            List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters
        ----------
        evaluations_ids : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Any]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluations/evaluation_scenarios/comparison-results",
            method="GET",
            params={
                "evaluations_ids": evaluations_ids,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def start_evaluation(
        self,
        *,
        revisions_ids: typing.Sequence[str],
        evaluators_configs: typing.Sequence[str],
        testset_revision_id: str,
        rate_limit: LlmRunRateLimit,
        name: typing.Optional[str] = OMIT,
        correct_answer_column: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        revisions_ids : typing.Sequence[str]

        evaluators_configs : typing.Sequence[str]

        testset_revision_id : str

        rate_limit : LlmRunRateLimit

        name : typing.Optional[str]

        correct_answer_column : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluations/preview/start",
            method="POST",
            json={
                "name": name,
                "revisions_ids": revisions_ids,
                "evaluators_configs": evaluators_configs,
                "testset_revision_id": testset_revision_id,
                "rate_limit": convert_and_respect_annotation_metadata(
                    object_=rate_limit, annotation=LlmRunRateLimit, direction="write"
                ),
                "correct_answer_column": correct_answer_column,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )


class AsyncRawEvaluationsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def refresh_runs(
        self,
        *,
        trigger_interval: typing.Optional[int] = None,
        trigger_datetime: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Any]:
        """
        Parameters
        ----------
        trigger_interval : typing.Optional[int]

        trigger_datetime : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Any]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/evaluations/runs/refresh",
            method="POST",
            params={
                "trigger_interval": trigger_interval,
                "trigger_datetime": serialize_datetime(trigger_datetime)
                if trigger_datetime is not None
                else None,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_runs(
        self,
        *,
        runs: typing.Sequence[EvaluationRunCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        runs : typing.Sequence[EvaluationRunCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/",
            method="POST",
            json={
                "runs": convert_and_respect_annotation_metadata(
                    object_=runs,
                    annotation=typing.Sequence[EvaluationRunCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_runs(
        self,
        *,
        run_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunIdsResponse]:
        """
        Parameters
        ----------
        run_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunIdsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/",
            method="DELETE",
            json={
                "run_ids": run_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunIdsResponse,
                    parse_obj_as(
                        type_=EvaluationRunIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_runs(
        self,
        *,
        runs: typing.Sequence[EvaluationRunEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        runs : typing.Sequence[EvaluationRunEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/",
            method="PATCH",
            json={
                "runs": convert_and_respect_annotation_metadata(
                    object_=runs,
                    annotation=typing.Sequence[EvaluationRunEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def query_runs(
        self,
        *,
        run: typing.Optional[EvaluationRunQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        run : typing.Optional[EvaluationRunQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/query",
            method="POST",
            json={
                "run": convert_and_respect_annotation_metadata(
                    object_=run,
                    annotation=typing.Optional[EvaluationRunQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def close_runs(
        self,
        *,
        run_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        run_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/close",
            method="POST",
            json={
                "run_ids": run_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def open_runs(
        self,
        *,
        run_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        run_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/runs/open",
            method="POST",
            json={
                "run_ids": run_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_run(
        self, run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_run(
        self, run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationRunIdResponse]:
        """
        Parameters
        ----------
        run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunIdResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunIdResponse,
                    parse_obj_as(
                        type_=EvaluationRunIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_run(
        self,
        run_id: str,
        *,
        run: EvaluationRunEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        run : EvaluationRunEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}",
            method="PATCH",
            json={
                "run": convert_and_respect_annotation_metadata(
                    object_=run, annotation=EvaluationRunEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def close_run(
        self,
        run_id: str,
        status: typing.Optional[EvaluationStatus],
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        status : typing.Optional[EvaluationStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}/close/{jsonable_encoder(status)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def open_run(
        self, run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationRunResponse]:
        """
        Parameters
        ----------
        run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/runs/{jsonable_encoder(run_id)}/open",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunResponse,
                    parse_obj_as(
                        type_=EvaluationRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_scenarios(
        self,
        *,
        scenarios: typing.Sequence[EvaluationScenarioCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenariosResponse]:
        """
        Parameters
        ----------
        scenarios : typing.Sequence[EvaluationScenarioCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenariosResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/",
            method="POST",
            json={
                "scenarios": convert_and_respect_annotation_metadata(
                    object_=scenarios,
                    annotation=typing.Sequence[EvaluationScenarioCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenariosResponse,
                    parse_obj_as(
                        type_=EvaluationScenariosResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_scenarios(
        self,
        *,
        scenario_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenarioIdsResponse]:
        """
        Parameters
        ----------
        scenario_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenarioIdsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/",
            method="DELETE",
            json={
                "scenario_ids": scenario_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioIdsResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_scenarios(
        self,
        *,
        scenarios: typing.Sequence[EvaluationScenarioEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenariosResponse]:
        """
        Parameters
        ----------
        scenarios : typing.Sequence[EvaluationScenarioEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenariosResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/",
            method="PATCH",
            json={
                "scenarios": convert_and_respect_annotation_metadata(
                    object_=scenarios,
                    annotation=typing.Sequence[EvaluationScenarioEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenariosResponse,
                    parse_obj_as(
                        type_=EvaluationScenariosResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def query_scenarios(
        self,
        *,
        scenario: typing.Optional[EvaluationScenarioQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenariosResponse]:
        """
        Parameters
        ----------
        scenario : typing.Optional[EvaluationScenarioQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenariosResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/scenarios/query",
            method="POST",
            json={
                "scenario": convert_and_respect_annotation_metadata(
                    object_=scenario,
                    annotation=typing.Optional[EvaluationScenarioQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenariosResponse,
                    parse_obj_as(
                        type_=EvaluationScenariosResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_scenario(
        self,
        scenario_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenarioResponse]:
        """
        Parameters
        ----------
        scenario_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenarioResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/scenarios/{jsonable_encoder(scenario_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_scenario(
        self,
        scenario_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenarioIdResponse]:
        """
        Parameters
        ----------
        scenario_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenarioIdResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/scenarios/{jsonable_encoder(scenario_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioIdResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_scenario(
        self,
        scenario_id: str,
        *,
        scenario: EvaluationScenarioEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationScenarioResponse]:
        """
        Parameters
        ----------
        scenario_id : str

        scenario : EvaluationScenarioEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationScenarioResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/scenarios/{jsonable_encoder(scenario_id)}",
            method="PATCH",
            json={
                "scenario": convert_and_respect_annotation_metadata(
                    object_=scenario,
                    annotation=EvaluationScenarioEdit,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationScenarioResponse,
                    parse_obj_as(
                        type_=EvaluationScenarioResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_results(
        self,
        *,
        results: typing.Sequence[EvaluationResultCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationResultsResponse]:
        """
        Parameters
        ----------
        results : typing.Sequence[EvaluationResultCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/",
            method="POST",
            json={
                "results": convert_and_respect_annotation_metadata(
                    object_=results,
                    annotation=typing.Sequence[EvaluationResultCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultsResponse,
                    parse_obj_as(
                        type_=EvaluationResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_results(
        self,
        *,
        result_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationResultIdsResponse]:
        """
        Parameters
        ----------
        result_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultIdsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/",
            method="DELETE",
            json={
                "result_ids": result_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultIdsResponse,
                    parse_obj_as(
                        type_=EvaluationResultIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_results(
        self,
        *,
        results: typing.Sequence[EvaluationResultEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationResultsResponse]:
        """
        Parameters
        ----------
        results : typing.Sequence[EvaluationResultEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/",
            method="PATCH",
            json={
                "results": convert_and_respect_annotation_metadata(
                    object_=results,
                    annotation=typing.Sequence[EvaluationResultEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultsResponse,
                    parse_obj_as(
                        type_=EvaluationResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def query_results(
        self,
        *,
        result: typing.Optional[EvaluationResultQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationResultsResponse]:
        """
        Parameters
        ----------
        result : typing.Optional[EvaluationResultQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/results/query",
            method="POST",
            json={
                "result": convert_and_respect_annotation_metadata(
                    object_=result,
                    annotation=typing.Optional[EvaluationResultQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultsResponse,
                    parse_obj_as(
                        type_=EvaluationResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_result(
        self, result_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationResultResponse]:
        """
        Parameters
        ----------
        result_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/results/{jsonable_encoder(result_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultResponse,
                    parse_obj_as(
                        type_=EvaluationResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_result(
        self, result_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationResultIdResponse]:
        """
        Parameters
        ----------
        result_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultIdResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/results/{jsonable_encoder(result_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultIdResponse,
                    parse_obj_as(
                        type_=EvaluationResultIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_result(
        self,
        result_id: str,
        *,
        result: EvaluationResultEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationResultResponse]:
        """
        Parameters
        ----------
        result_id : str

        result : EvaluationResultEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationResultResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/results/{jsonable_encoder(result_id)}",
            method="PATCH",
            json={
                "result": convert_and_respect_annotation_metadata(
                    object_=result, annotation=EvaluationResultEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationResultResponse,
                    parse_obj_as(
                        type_=EvaluationResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def refresh_metrics(
        self,
        *,
        metrics: EvaluationMetricsRefresh,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : EvaluationMetricsRefresh

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/refresh",
            method="POST",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=EvaluationMetricsRefresh,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_metrics(
        self,
        *,
        metrics: typing.Sequence[EvaluationMetricsCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : typing.Sequence[EvaluationMetricsCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/",
            method="POST",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=typing.Sequence[EvaluationMetricsCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_metrics(
        self,
        *,
        metrics_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationMetricsIdsResponse]:
        """
        Parameters
        ----------
        metrics_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationMetricsIdsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/",
            method="DELETE",
            json={
                "metrics_ids": metrics_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsIdsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_metrics(
        self,
        *,
        metrics: typing.Sequence[EvaluationMetricsEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : typing.Sequence[EvaluationMetricsEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/",
            method="PATCH",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=typing.Sequence[EvaluationMetricsEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def query_metrics(
        self,
        *,
        metrics: typing.Optional[EvaluationMetricsQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationMetricsResponse]:
        """
        Parameters
        ----------
        metrics : typing.Optional[EvaluationMetricsQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationMetricsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/metrics/query",
            method="POST",
            json={
                "metrics": convert_and_respect_annotation_metadata(
                    object_=metrics,
                    annotation=typing.Optional[EvaluationMetricsQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationMetricsResponse,
                    parse_obj_as(
                        type_=EvaluationMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_queues(
        self,
        *,
        queues: typing.Sequence[EvaluationQueueCreate],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationQueuesResponse]:
        """
        Parameters
        ----------
        queues : typing.Sequence[EvaluationQueueCreate]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueuesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/",
            method="POST",
            json={
                "queues": convert_and_respect_annotation_metadata(
                    object_=queues,
                    annotation=typing.Sequence[EvaluationQueueCreate],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueuesResponse,
                    parse_obj_as(
                        type_=EvaluationQueuesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_queues(
        self,
        *,
        queue_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationQueueIdsResponse]:
        """
        Parameters
        ----------
        queue_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueueIdsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/",
            method="DELETE",
            json={
                "queue_ids": queue_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueIdsResponse,
                    parse_obj_as(
                        type_=EvaluationQueueIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_queues(
        self,
        *,
        queues: typing.Sequence[EvaluationQueueEdit],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationQueuesResponse]:
        """
        Parameters
        ----------
        queues : typing.Sequence[EvaluationQueueEdit]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueuesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/",
            method="PATCH",
            json={
                "queues": convert_and_respect_annotation_metadata(
                    object_=queues,
                    annotation=typing.Sequence[EvaluationQueueEdit],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueuesResponse,
                    parse_obj_as(
                        type_=EvaluationQueuesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def query_queues(
        self,
        *,
        queue: typing.Optional[EvaluationQueueQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationQueuesResponse]:
        """
        Parameters
        ----------
        queue : typing.Optional[EvaluationQueueQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueuesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluations/queues/query",
            method="POST",
            json={
                "queue": convert_and_respect_annotation_metadata(
                    object_=queue,
                    annotation=typing.Optional[EvaluationQueueQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueuesResponse,
                    parse_obj_as(
                        type_=EvaluationQueuesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_queue(
        self, queue_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationQueueResponse]:
        """
        Parameters
        ----------
        queue_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueueResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueResponse,
                    parse_obj_as(
                        type_=EvaluationQueueResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_queue(
        self, queue_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluationQueueIdResponse]:
        """
        Parameters
        ----------
        queue_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueueIdResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueIdResponse,
                    parse_obj_as(
                        type_=EvaluationQueueIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_queue(
        self,
        queue_id: str,
        *,
        queue: EvaluationQueueEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationQueueResponse]:
        """
        Parameters
        ----------
        queue_id : str

        queue : EvaluationQueueEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueueResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}",
            method="PATCH",
            json={
                "queue": convert_and_respect_annotation_metadata(
                    object_=queue, annotation=EvaluationQueueEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueResponse,
                    parse_obj_as(
                        type_=EvaluationQueueResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_queue_scenarios(
        self,
        queue_id: str,
        *,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationQueueScenarioIdsResponse]:
        """
        Parameters
        ----------
        queue_id : str

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationQueueScenarioIdsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluations/queues/{jsonable_encoder(queue_id)}/scenarios",
            method="GET",
            params={
                "user_id": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationQueueScenarioIdsResponse,
                    parse_obj_as(
                        type_=EvaluationQueueScenarioIdsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_evaluation(
        self,
        *,
        evaluation: SimpleEvaluationCreate,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation : SimpleEvaluationCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/simple/evaluations/",
            method="POST",
            json={
                "evaluation": convert_and_respect_annotation_metadata(
                    object_=evaluation,
                    annotation=SimpleEvaluationCreate,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationIdResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationIdResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationIdResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_evaluation(
        self,
        evaluation_id: str,
        *,
        evaluation: SimpleEvaluationEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        evaluation : SimpleEvaluationEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}",
            method="PATCH",
            json={
                "evaluation": convert_and_respect_annotation_metadata(
                    object_=evaluation,
                    annotation=SimpleEvaluationEdit,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def query_evaluations(
        self,
        *,
        evaluation: typing.Optional[SimpleEvaluationQuery] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationsResponse]:
        """
        Parameters
        ----------
        evaluation : typing.Optional[SimpleEvaluationQuery]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/simple/evaluations/query",
            method="POST",
            json={
                "evaluation": convert_and_respect_annotation_metadata(
                    object_=evaluation,
                    annotation=typing.Optional[SimpleEvaluationQuery],
                    direction="write",
                ),
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing,
                    annotation=typing.Optional[Windowing],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationsResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def start_simple_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/start",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def stop_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/stop",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def close_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/close",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def open_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluationResponse]:
        """
        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluations/{jsonable_encoder(evaluation_id)}/open",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluationResponse,
                    parse_obj_as(
                        type_=SimpleEvaluationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_evaluation_ids(
        self,
        *,
        resource_type: str,
        resource_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[str]]:
        """
        Fetches evaluation ids for a given resource type and id.

        Arguments:
            app_id (str): The ID of the app for which to fetch evaluations.
            resource_type (str): The type of resource for which to fetch evaluations.
            resource_ids List[ObjectId]: The IDs of resource for which to fetch evaluations.

        Raises:
            HTTPException: If the resource_type is invalid or access is denied.

        Returns:
            List[str]: A list of evaluation ids.

        Parameters
        ----------
        resource_type : str

        resource_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[str]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluations/by_resource",
            method="GET",
            params={
                "resource_type": resource_type,
                "resource_ids": resource_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_evaluation_status(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Any]:
        """
        Fetches the status of the evaluation.

        Args:
            evaluation_id (str): the evaluation id
            request (Request): the request object

        Returns:
            (str): the evaluation status

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Any]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_legacy_evaluation_results(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Any]:
        """
        Fetches the results of the evaluation

        Args:
            evaluation_id (str): the evaluation id
            request (Request): the request object

        Returns:
            _type_: _description_

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Any]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}/results",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_legacy_evaluation_scenarios(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[
        typing.List[OssSrcModelsApiEvaluationModelEvaluationScenario]
    ]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
            evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
            HTTPException: If the evaluation is not found or access is denied.

        Returns:
            List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[OssSrcModelsApiEvaluationModelEvaluationScenario]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}/evaluation_scenarios",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[OssSrcModelsApiEvaluationModelEvaluationScenario],
                    parse_obj_as(
                        type_=typing.List[
                            OssSrcModelsApiEvaluationModelEvaluationScenario
                        ],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_legacy_evaluations(
        self, *, app_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[Evaluation]]:
        """
        Fetches a list of evaluations, optionally filtered by an app ID.

        Args:
            app_id (Optional[str]): An optional app ID to filter the evaluations.

        Returns:
            List[Evaluation]: A list of evaluations.

        Parameters
        ----------
        app_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Evaluation]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluations",
            method="GET",
            params={
                "app_id": app_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Evaluation],
                    parse_obj_as(
                        type_=typing.List[Evaluation],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_legacy_evaluations(
        self,
        *,
        evaluations_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[str]]:
        """
        Delete specific comparison tables based on their unique IDs.

        Args:
        delete_evaluations (List[str]): The unique identifiers of the comparison tables to delete.

        Returns:
        A list of the deleted comparison tables' IDs.

        Parameters
        ----------
        evaluations_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[str]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluations",
            method="DELETE",
            json={
                "evaluations_ids": evaluations_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_legacy_evaluation(
        self,
        evaluation_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Evaluation]:
        """
        Fetches a single evaluation based on its ID.

        Args:
            evaluation_id (str): The ID of the evaluation to fetch.

        Returns:
            Evaluation: The fetched evaluation.

        Parameters
        ----------
        evaluation_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Evaluation]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluations/{jsonable_encoder(evaluation_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Evaluation,
                    parse_obj_as(
                        type_=Evaluation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def fetch_legacy_evaluation_scenarios_comparison_results(
        self,
        *,
        evaluations_ids: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Any]:
        """
        Fetches evaluation scenarios for a given evaluation ID.

        Arguments:
            evaluation_id (str): The ID of the evaluation for which to fetch scenarios.

        Raises:
            HTTPException: If the evaluation is not found or access is denied.

        Returns:
            List[EvaluationScenario]: A list of evaluation scenarios.

        Parameters
        ----------
        evaluations_ids : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Any]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluations/evaluation_scenarios/comparison-results",
            method="GET",
            params={
                "evaluations_ids": evaluations_ids,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    parse_obj_as(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def start_evaluation(
        self,
        *,
        revisions_ids: typing.Sequence[str],
        evaluators_configs: typing.Sequence[str],
        testset_revision_id: str,
        rate_limit: LlmRunRateLimit,
        name: typing.Optional[str] = OMIT,
        correct_answer_column: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluationRunsResponse]:
        """
        Parameters
        ----------
        revisions_ids : typing.Sequence[str]

        evaluators_configs : typing.Sequence[str]

        testset_revision_id : str

        rate_limit : LlmRunRateLimit

        name : typing.Optional[str]

        correct_answer_column : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluationRunsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluations/preview/start",
            method="POST",
            json={
                "name": name,
                "revisions_ids": revisions_ids,
                "evaluators_configs": evaluators_configs,
                "testset_revision_id": testset_revision_id,
                "rate_limit": convert_and_respect_annotation_metadata(
                    object_=rate_limit, annotation=LlmRunRateLimit, direction="write"
                ),
                "correct_answer_column": correct_answer_column,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluationRunsResponse,
                    parse_obj_as(
                        type_=EvaluationRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )
