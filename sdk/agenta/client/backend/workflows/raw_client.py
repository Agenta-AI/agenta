# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.full_json_input import FullJsonInput
from ..types.http_validation_error import HttpValidationError
from ..types.label_json_input import LabelJsonInput
from ..types.workflow_create import WorkflowCreate
from ..types.workflow_edit import WorkflowEdit
from ..types.workflow_fork import WorkflowFork
from ..types.workflow_response import WorkflowResponse
from ..types.workflow_revision_commit import WorkflowRevisionCommit
from ..types.workflow_revision_create import WorkflowRevisionCreate
from ..types.workflow_revision_edit import WorkflowRevisionEdit
from ..types.workflow_revision_response import WorkflowRevisionResponse
from ..types.workflow_revisions_log import WorkflowRevisionsLog
from ..types.workflow_revisions_response import WorkflowRevisionsResponse
from ..types.workflow_service_request_data import WorkflowServiceRequestData
from ..types.workflow_service_request_input_configuration import WorkflowServiceRequestInputConfiguration
from ..types.workflow_service_request_input_interface import WorkflowServiceRequestInputInterface
from ..types.workflow_service_request_input_links_value import WorkflowServiceRequestInputLinksValue
from ..types.workflow_service_request_input_references_value import WorkflowServiceRequestInputReferencesValue
from ..types.workflow_service_request_output import WorkflowServiceRequestOutput
from ..types.workflow_variant_create import WorkflowVariantCreate
from ..types.workflow_variant_edit import WorkflowVariantEdit
from ..types.workflow_variant_response import WorkflowVariantResponse
from ..types.workflow_variants_response import WorkflowVariantsResponse
from ..types.workflows_response import WorkflowsResponse
from .types.invoke_workflow_response import InvokeWorkflowResponse
from .types.query_workflow_revisions_request_order import QueryWorkflowRevisionsRequestOrder
from .types.query_workflow_variants_request_order import QueryWorkflowVariantsRequestOrder
from .types.query_workflows_request_order import QueryWorkflowsRequestOrder

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWorkflowsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_workflow(
        self, *, workflow: WorkflowCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow : WorkflowCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/",
            method="POST",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_workflow(
        self, workflow_id: str, *, workflow: WorkflowEdit, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        workflow : WorkflowEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}",
            method="PUT",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_workflows(
        self,
        *,
        workflow_id: typing.Optional[str] = None,
        workflow_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_slug: typing.Optional[str] = None,
        workflow_slugs: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryWorkflowsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowsResponse]:
        """
        Parameters
        ----------
        workflow_id : typing.Optional[str]

        workflow_ids : typing.Optional[typing.Sequence[str]]

        workflow_slug : typing.Optional[str]

        workflow_slugs : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryWorkflowsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/query",
            method="POST",
            params={
                "workflow_id": workflow_id,
                "workflow_ids": workflow_ids,
                "workflow_slug": workflow_slug,
                "workflow_slugs": workflow_slugs,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsResponse,
                    parse_obj_as(
                        type_=WorkflowsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_workflow_variant(
        self, *, workflow_variant: WorkflowVariantCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant : WorkflowVariantCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/variants/",
            method="POST",
            json={
                "workflow_variant": convert_and_respect_annotation_metadata(
                    object_=workflow_variant, annotation=WorkflowVariantCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_workflow_variant(
        self, workflow_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_workflow_variant(
        self,
        workflow_variant_id: str,
        *,
        workflow_variant: WorkflowVariantEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        workflow_variant : WorkflowVariantEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}",
            method="PUT",
            json={
                "workflow_variant": convert_and_respect_annotation_metadata(
                    object_=workflow_variant, annotation=WorkflowVariantEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_workflow_variant(
        self, workflow_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_workflow_variant(
        self, workflow_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_workflow_variants(
        self,
        *,
        workflow_id: typing.Optional[str] = None,
        workflow_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_slug: typing.Optional[str] = None,
        workflow_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_id: typing.Optional[str] = None,
        workflow_variant_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_slug: typing.Optional[str] = None,
        workflow_variant_slugs: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryWorkflowVariantsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowVariantsResponse]:
        """
        Parameters
        ----------
        workflow_id : typing.Optional[str]

        workflow_ids : typing.Optional[typing.Sequence[str]]

        workflow_slug : typing.Optional[str]

        workflow_slugs : typing.Optional[typing.Sequence[str]]

        workflow_variant_id : typing.Optional[str]

        workflow_variant_ids : typing.Optional[typing.Sequence[str]]

        workflow_variant_slug : typing.Optional[str]

        workflow_variant_slugs : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryWorkflowVariantsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/variants/query",
            method="POST",
            params={
                "workflow_id": workflow_id,
                "workflow_ids": workflow_ids,
                "workflow_slug": workflow_slug,
                "workflow_slugs": workflow_slugs,
                "workflow_variant_id": workflow_variant_id,
                "workflow_variant_ids": workflow_variant_ids,
                "workflow_variant_slug": workflow_variant_slug,
                "workflow_variant_slugs": workflow_variant_slugs,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantsResponse,
                    parse_obj_as(
                        type_=WorkflowVariantsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fork_workflow_variant(
        self, *, workflow: WorkflowFork, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow : WorkflowFork

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/variants/fork",
            method="POST",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowFork, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve_workflow_revision(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/retrieve",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_workflow_revision(
        self, *, workflow_revision: WorkflowRevisionCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision : WorkflowRevisionCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/",
            method="POST",
            json={
                "workflow_revision": convert_and_respect_annotation_metadata(
                    object_=workflow_revision, annotation=WorkflowRevisionCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_workflow_revision(
        self, workflow_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_workflow_revision(
        self,
        workflow_revision_id: str,
        *,
        workflow_revision: WorkflowRevisionEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        workflow_revision : WorkflowRevisionEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}",
            method="PUT",
            json={
                "workflow_revision": convert_and_respect_annotation_metadata(
                    object_=workflow_revision, annotation=WorkflowRevisionEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_workflow_revision_rpc(
        self, workflow_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_workflow_revision_rpc(
        self, workflow_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_workflow_revisions(
        self,
        *,
        workflow_id: typing.Optional[str] = None,
        workflow_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_slug: typing.Optional[str] = None,
        workflow_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_id: typing.Optional[str] = None,
        workflow_variant_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_slug: typing.Optional[str] = None,
        workflow_variant_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_revision_id: typing.Optional[str] = None,
        workflow_revision_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_revision_slug: typing.Optional[str] = None,
        workflow_revision_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_revision_version: typing.Optional[str] = None,
        workflow_revision_versions: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryWorkflowRevisionsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowRevisionsResponse]:
        """
        Parameters
        ----------
        workflow_id : typing.Optional[str]

        workflow_ids : typing.Optional[typing.Sequence[str]]

        workflow_slug : typing.Optional[str]

        workflow_slugs : typing.Optional[typing.Sequence[str]]

        workflow_variant_id : typing.Optional[str]

        workflow_variant_ids : typing.Optional[typing.Sequence[str]]

        workflow_variant_slug : typing.Optional[str]

        workflow_variant_slugs : typing.Optional[typing.Sequence[str]]

        workflow_revision_id : typing.Optional[str]

        workflow_revision_ids : typing.Optional[typing.Sequence[str]]

        workflow_revision_slug : typing.Optional[str]

        workflow_revision_slugs : typing.Optional[typing.Sequence[str]]

        workflow_revision_version : typing.Optional[str]

        workflow_revision_versions : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryWorkflowRevisionsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/query",
            method="POST",
            params={
                "workflow_id": workflow_id,
                "workflow_ids": workflow_ids,
                "workflow_slug": workflow_slug,
                "workflow_slugs": workflow_slugs,
                "workflow_variant_id": workflow_variant_id,
                "workflow_variant_ids": workflow_variant_ids,
                "workflow_variant_slug": workflow_variant_slug,
                "workflow_variant_slugs": workflow_variant_slugs,
                "workflow_revision_id": workflow_revision_id,
                "workflow_revision_ids": workflow_revision_ids,
                "workflow_revision_slug": workflow_revision_slug,
                "workflow_revision_slugs": workflow_revision_slugs,
                "workflow_revision_version": workflow_revision_version,
                "workflow_revision_versions": workflow_revision_versions,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionsResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def commit_workflow_revision(
        self,
        *,
        workflow_revision: WorkflowRevisionCommit,
        workflow_variant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision : WorkflowRevisionCommit

        workflow_variant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/commit",
            method="POST",
            params={
                "workflow_variant_id": workflow_variant_id,
            },
            json={
                "workflow_revision": convert_and_respect_annotation_metadata(
                    object_=workflow_revision, annotation=WorkflowRevisionCommit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def log_workflow_revisions(
        self, *, workflow: WorkflowRevisionsLog, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowRevisionsResponse]:
        """
        Parameters
        ----------
        workflow : WorkflowRevisionsLog

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowRevisionsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/log",
            method="POST",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowRevisionsLog, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionsResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def invoke_workflow(
        self,
        *,
        flags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        tags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]] = OMIT,
        version: typing.Optional[str] = OMIT,
        interface: typing.Optional[WorkflowServiceRequestInputInterface] = OMIT,
        configuration: typing.Optional[WorkflowServiceRequestInputConfiguration] = OMIT,
        references: typing.Optional[
            typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
        ] = OMIT,
        links: typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]] = OMIT,
        secrets: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        credentials: typing.Optional[str] = OMIT,
        data: typing.Optional[WorkflowServiceRequestData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InvokeWorkflowResponse]:
        """
        Parameters
        ----------
        flags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        tags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        meta : typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]]

        version : typing.Optional[str]

        interface : typing.Optional[WorkflowServiceRequestInputInterface]

        configuration : typing.Optional[WorkflowServiceRequestInputConfiguration]

        references : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]]

        links : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]]

        secrets : typing.Optional[typing.Dict[str, typing.Any]]

        credentials : typing.Optional[str]

        data : typing.Optional[WorkflowServiceRequestData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InvokeWorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/invoke",
            method="POST",
            json={
                "flags": convert_and_respect_annotation_metadata(
                    object_=flags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "meta": convert_and_respect_annotation_metadata(
                    object_=meta,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]],
                    direction="write",
                ),
                "version": version,
                "interface": convert_and_respect_annotation_metadata(
                    object_=interface,
                    annotation=typing.Optional[WorkflowServiceRequestInputInterface],
                    direction="write",
                ),
                "configuration": convert_and_respect_annotation_metadata(
                    object_=configuration,
                    annotation=typing.Optional[WorkflowServiceRequestInputConfiguration],
                    direction="write",
                ),
                "references": convert_and_respect_annotation_metadata(
                    object_=references,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
                    ],
                    direction="write",
                ),
                "links": convert_and_respect_annotation_metadata(
                    object_=links,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]
                    ],
                    direction="write",
                ),
                "secrets": secrets,
                "credentials": credentials,
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Optional[WorkflowServiceRequestData], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InvokeWorkflowResponse,
                    parse_obj_as(
                        type_=InvokeWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def inspect_workflow(
        self,
        *,
        flags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        tags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]] = OMIT,
        version: typing.Optional[str] = OMIT,
        interface: typing.Optional[WorkflowServiceRequestInputInterface] = OMIT,
        configuration: typing.Optional[WorkflowServiceRequestInputConfiguration] = OMIT,
        references: typing.Optional[
            typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
        ] = OMIT,
        links: typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]] = OMIT,
        secrets: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        credentials: typing.Optional[str] = OMIT,
        data: typing.Optional[WorkflowServiceRequestData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowServiceRequestOutput]:
        """
        Parameters
        ----------
        flags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        tags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        meta : typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]]

        version : typing.Optional[str]

        interface : typing.Optional[WorkflowServiceRequestInputInterface]

        configuration : typing.Optional[WorkflowServiceRequestInputConfiguration]

        references : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]]

        links : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]]

        secrets : typing.Optional[typing.Dict[str, typing.Any]]

        credentials : typing.Optional[str]

        data : typing.Optional[WorkflowServiceRequestData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowServiceRequestOutput]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/workflows/inspect",
            method="POST",
            json={
                "flags": convert_and_respect_annotation_metadata(
                    object_=flags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "meta": convert_and_respect_annotation_metadata(
                    object_=meta,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]],
                    direction="write",
                ),
                "version": version,
                "interface": convert_and_respect_annotation_metadata(
                    object_=interface,
                    annotation=typing.Optional[WorkflowServiceRequestInputInterface],
                    direction="write",
                ),
                "configuration": convert_and_respect_annotation_metadata(
                    object_=configuration,
                    annotation=typing.Optional[WorkflowServiceRequestInputConfiguration],
                    direction="write",
                ),
                "references": convert_and_respect_annotation_metadata(
                    object_=references,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
                    ],
                    direction="write",
                ),
                "links": convert_and_respect_annotation_metadata(
                    object_=links,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]
                    ],
                    direction="write",
                ),
                "secrets": secrets,
                "credentials": credentials,
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Optional[WorkflowServiceRequestData], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowServiceRequestOutput,
                    parse_obj_as(
                        type_=WorkflowServiceRequestOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawWorkflowsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_workflow(
        self, *, workflow: WorkflowCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow : WorkflowCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/",
            method="POST",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_workflow(
        self, workflow_id: str, *, workflow: WorkflowEdit, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        workflow : WorkflowEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}",
            method="PUT",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/{jsonable_encoder(workflow_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    parse_obj_as(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_workflows(
        self,
        *,
        workflow_id: typing.Optional[str] = None,
        workflow_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_slug: typing.Optional[str] = None,
        workflow_slugs: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryWorkflowsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowsResponse]:
        """
        Parameters
        ----------
        workflow_id : typing.Optional[str]

        workflow_ids : typing.Optional[typing.Sequence[str]]

        workflow_slug : typing.Optional[str]

        workflow_slugs : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryWorkflowsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/query",
            method="POST",
            params={
                "workflow_id": workflow_id,
                "workflow_ids": workflow_ids,
                "workflow_slug": workflow_slug,
                "workflow_slugs": workflow_slugs,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowsResponse,
                    parse_obj_as(
                        type_=WorkflowsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_workflow_variant(
        self, *, workflow_variant: WorkflowVariantCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant : WorkflowVariantCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/variants/",
            method="POST",
            json={
                "workflow_variant": convert_and_respect_annotation_metadata(
                    object_=workflow_variant, annotation=WorkflowVariantCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_workflow_variant(
        self, workflow_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_workflow_variant(
        self,
        workflow_variant_id: str,
        *,
        workflow_variant: WorkflowVariantEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        workflow_variant : WorkflowVariantEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}",
            method="PUT",
            json={
                "workflow_variant": convert_and_respect_annotation_metadata(
                    object_=workflow_variant, annotation=WorkflowVariantEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_workflow_variant(
        self, workflow_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_workflow_variant(
        self, workflow_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/variants/{jsonable_encoder(workflow_variant_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_workflow_variants(
        self,
        *,
        workflow_id: typing.Optional[str] = None,
        workflow_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_slug: typing.Optional[str] = None,
        workflow_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_id: typing.Optional[str] = None,
        workflow_variant_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_slug: typing.Optional[str] = None,
        workflow_variant_slugs: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryWorkflowVariantsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowVariantsResponse]:
        """
        Parameters
        ----------
        workflow_id : typing.Optional[str]

        workflow_ids : typing.Optional[typing.Sequence[str]]

        workflow_slug : typing.Optional[str]

        workflow_slugs : typing.Optional[typing.Sequence[str]]

        workflow_variant_id : typing.Optional[str]

        workflow_variant_ids : typing.Optional[typing.Sequence[str]]

        workflow_variant_slug : typing.Optional[str]

        workflow_variant_slugs : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryWorkflowVariantsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/variants/query",
            method="POST",
            params={
                "workflow_id": workflow_id,
                "workflow_ids": workflow_ids,
                "workflow_slug": workflow_slug,
                "workflow_slugs": workflow_slugs,
                "workflow_variant_id": workflow_variant_id,
                "workflow_variant_ids": workflow_variant_ids,
                "workflow_variant_slug": workflow_variant_slug,
                "workflow_variant_slugs": workflow_variant_slugs,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantsResponse,
                    parse_obj_as(
                        type_=WorkflowVariantsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fork_workflow_variant(
        self, *, workflow: WorkflowFork, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowVariantResponse]:
        """
        Parameters
        ----------
        workflow : WorkflowFork

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/variants/fork",
            method="POST",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowFork, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowVariantResponse,
                    parse_obj_as(
                        type_=WorkflowVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve_workflow_revision(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/retrieve",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_workflow_revision(
        self, *, workflow_revision: WorkflowRevisionCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision : WorkflowRevisionCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/",
            method="POST",
            json={
                "workflow_revision": convert_and_respect_annotation_metadata(
                    object_=workflow_revision, annotation=WorkflowRevisionCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_workflow_revision(
        self, workflow_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_workflow_revision(
        self,
        workflow_revision_id: str,
        *,
        workflow_revision: WorkflowRevisionEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        workflow_revision : WorkflowRevisionEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}",
            method="PUT",
            json={
                "workflow_revision": convert_and_respect_annotation_metadata(
                    object_=workflow_revision, annotation=WorkflowRevisionEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_workflow_revision_rpc(
        self, workflow_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_workflow_revision_rpc(
        self, workflow_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/workflows/revisions/{jsonable_encoder(workflow_revision_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_workflow_revisions(
        self,
        *,
        workflow_id: typing.Optional[str] = None,
        workflow_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_slug: typing.Optional[str] = None,
        workflow_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_id: typing.Optional[str] = None,
        workflow_variant_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_variant_slug: typing.Optional[str] = None,
        workflow_variant_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_revision_id: typing.Optional[str] = None,
        workflow_revision_ids: typing.Optional[typing.Sequence[str]] = None,
        workflow_revision_slug: typing.Optional[str] = None,
        workflow_revision_slugs: typing.Optional[typing.Sequence[str]] = None,
        workflow_revision_version: typing.Optional[str] = None,
        workflow_revision_versions: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryWorkflowRevisionsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowRevisionsResponse]:
        """
        Parameters
        ----------
        workflow_id : typing.Optional[str]

        workflow_ids : typing.Optional[typing.Sequence[str]]

        workflow_slug : typing.Optional[str]

        workflow_slugs : typing.Optional[typing.Sequence[str]]

        workflow_variant_id : typing.Optional[str]

        workflow_variant_ids : typing.Optional[typing.Sequence[str]]

        workflow_variant_slug : typing.Optional[str]

        workflow_variant_slugs : typing.Optional[typing.Sequence[str]]

        workflow_revision_id : typing.Optional[str]

        workflow_revision_ids : typing.Optional[typing.Sequence[str]]

        workflow_revision_slug : typing.Optional[str]

        workflow_revision_slugs : typing.Optional[typing.Sequence[str]]

        workflow_revision_version : typing.Optional[str]

        workflow_revision_versions : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryWorkflowRevisionsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/query",
            method="POST",
            params={
                "workflow_id": workflow_id,
                "workflow_ids": workflow_ids,
                "workflow_slug": workflow_slug,
                "workflow_slugs": workflow_slugs,
                "workflow_variant_id": workflow_variant_id,
                "workflow_variant_ids": workflow_variant_ids,
                "workflow_variant_slug": workflow_variant_slug,
                "workflow_variant_slugs": workflow_variant_slugs,
                "workflow_revision_id": workflow_revision_id,
                "workflow_revision_ids": workflow_revision_ids,
                "workflow_revision_slug": workflow_revision_slug,
                "workflow_revision_slugs": workflow_revision_slugs,
                "workflow_revision_version": workflow_revision_version,
                "workflow_revision_versions": workflow_revision_versions,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionsResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def commit_workflow_revision(
        self,
        *,
        workflow_revision: WorkflowRevisionCommit,
        workflow_variant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowRevisionResponse]:
        """
        Parameters
        ----------
        workflow_revision : WorkflowRevisionCommit

        workflow_variant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/commit",
            method="POST",
            params={
                "workflow_variant_id": workflow_variant_id,
            },
            json={
                "workflow_revision": convert_and_respect_annotation_metadata(
                    object_=workflow_revision, annotation=WorkflowRevisionCommit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def log_workflow_revisions(
        self, *, workflow: WorkflowRevisionsLog, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowRevisionsResponse]:
        """
        Parameters
        ----------
        workflow : WorkflowRevisionsLog

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowRevisionsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/revisions/log",
            method="POST",
            json={
                "workflow": convert_and_respect_annotation_metadata(
                    object_=workflow, annotation=WorkflowRevisionsLog, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowRevisionsResponse,
                    parse_obj_as(
                        type_=WorkflowRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def invoke_workflow(
        self,
        *,
        flags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        tags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]] = OMIT,
        version: typing.Optional[str] = OMIT,
        interface: typing.Optional[WorkflowServiceRequestInputInterface] = OMIT,
        configuration: typing.Optional[WorkflowServiceRequestInputConfiguration] = OMIT,
        references: typing.Optional[
            typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
        ] = OMIT,
        links: typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]] = OMIT,
        secrets: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        credentials: typing.Optional[str] = OMIT,
        data: typing.Optional[WorkflowServiceRequestData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InvokeWorkflowResponse]:
        """
        Parameters
        ----------
        flags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        tags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        meta : typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]]

        version : typing.Optional[str]

        interface : typing.Optional[WorkflowServiceRequestInputInterface]

        configuration : typing.Optional[WorkflowServiceRequestInputConfiguration]

        references : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]]

        links : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]]

        secrets : typing.Optional[typing.Dict[str, typing.Any]]

        credentials : typing.Optional[str]

        data : typing.Optional[WorkflowServiceRequestData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InvokeWorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/invoke",
            method="POST",
            json={
                "flags": convert_and_respect_annotation_metadata(
                    object_=flags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "meta": convert_and_respect_annotation_metadata(
                    object_=meta,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]],
                    direction="write",
                ),
                "version": version,
                "interface": convert_and_respect_annotation_metadata(
                    object_=interface,
                    annotation=typing.Optional[WorkflowServiceRequestInputInterface],
                    direction="write",
                ),
                "configuration": convert_and_respect_annotation_metadata(
                    object_=configuration,
                    annotation=typing.Optional[WorkflowServiceRequestInputConfiguration],
                    direction="write",
                ),
                "references": convert_and_respect_annotation_metadata(
                    object_=references,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
                    ],
                    direction="write",
                ),
                "links": convert_and_respect_annotation_metadata(
                    object_=links,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]
                    ],
                    direction="write",
                ),
                "secrets": secrets,
                "credentials": credentials,
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Optional[WorkflowServiceRequestData], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InvokeWorkflowResponse,
                    parse_obj_as(
                        type_=InvokeWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def inspect_workflow(
        self,
        *,
        flags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        tags: typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]] = OMIT,
        version: typing.Optional[str] = OMIT,
        interface: typing.Optional[WorkflowServiceRequestInputInterface] = OMIT,
        configuration: typing.Optional[WorkflowServiceRequestInputConfiguration] = OMIT,
        references: typing.Optional[
            typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
        ] = OMIT,
        links: typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]] = OMIT,
        secrets: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        credentials: typing.Optional[str] = OMIT,
        data: typing.Optional[WorkflowServiceRequestData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowServiceRequestOutput]:
        """
        Parameters
        ----------
        flags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        tags : typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]]

        meta : typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]]

        version : typing.Optional[str]

        interface : typing.Optional[WorkflowServiceRequestInputInterface]

        configuration : typing.Optional[WorkflowServiceRequestInputConfiguration]

        references : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]]

        links : typing.Optional[typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]]

        secrets : typing.Optional[typing.Dict[str, typing.Any]]

        credentials : typing.Optional[str]

        data : typing.Optional[WorkflowServiceRequestData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowServiceRequestOutput]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/workflows/inspect",
            method="POST",
            json={
                "flags": convert_and_respect_annotation_metadata(
                    object_=flags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[LabelJsonInput]]],
                    direction="write",
                ),
                "meta": convert_and_respect_annotation_metadata(
                    object_=meta,
                    annotation=typing.Optional[typing.Dict[str, typing.Optional[FullJsonInput]]],
                    direction="write",
                ),
                "version": version,
                "interface": convert_and_respect_annotation_metadata(
                    object_=interface,
                    annotation=typing.Optional[WorkflowServiceRequestInputInterface],
                    direction="write",
                ),
                "configuration": convert_and_respect_annotation_metadata(
                    object_=configuration,
                    annotation=typing.Optional[WorkflowServiceRequestInputConfiguration],
                    direction="write",
                ),
                "references": convert_and_respect_annotation_metadata(
                    object_=references,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputReferencesValue]]
                    ],
                    direction="write",
                ),
                "links": convert_and_respect_annotation_metadata(
                    object_=links,
                    annotation=typing.Optional[
                        typing.Dict[str, typing.Optional[WorkflowServiceRequestInputLinksValue]]
                    ],
                    direction="write",
                ),
                "secrets": secrets,
                "credentials": credentials,
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Optional[WorkflowServiceRequestData], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowServiceRequestOutput,
                    parse_obj_as(
                        type_=WorkflowServiceRequestOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
