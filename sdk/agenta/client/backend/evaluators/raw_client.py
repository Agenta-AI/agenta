# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.evaluator_config import EvaluatorConfig
from ..types.evaluator_create import EvaluatorCreate
from ..types.evaluator_edit import EvaluatorEdit
from ..types.evaluator_fork import EvaluatorFork
from ..types.evaluator_mapping_output_interface import EvaluatorMappingOutputInterface
from ..types.evaluator_output_interface import EvaluatorOutputInterface
from ..types.evaluator_query import EvaluatorQuery
from ..types.evaluator_response import EvaluatorResponse
from ..types.evaluator_revision_commit import EvaluatorRevisionCommit
from ..types.evaluator_revision_create import EvaluatorRevisionCreate
from ..types.evaluator_revision_edit import EvaluatorRevisionEdit
from ..types.evaluator_revision_query import EvaluatorRevisionQuery
from ..types.evaluator_revision_response import EvaluatorRevisionResponse
from ..types.evaluator_revisions_log import EvaluatorRevisionsLog
from ..types.evaluator_revisions_response import EvaluatorRevisionsResponse
from ..types.evaluator_variant_create import EvaluatorVariantCreate
from ..types.evaluator_variant_edit import EvaluatorVariantEdit
from ..types.evaluator_variant_response import EvaluatorVariantResponse
from ..types.evaluator_variants_response import EvaluatorVariantsResponse
from ..types.evaluators_response import EvaluatorsResponse
from ..types.http_validation_error import HttpValidationError
from ..types.legacy_evaluator import LegacyEvaluator
from ..types.reference import Reference
from ..types.simple_evaluator_create import SimpleEvaluatorCreate
from ..types.simple_evaluator_edit import SimpleEvaluatorEdit
from ..types.simple_evaluator_query import SimpleEvaluatorQuery
from ..types.simple_evaluator_response import SimpleEvaluatorResponse
from ..types.simple_evaluators_response import SimpleEvaluatorsResponse
from ..types.windowing import Windowing
from .types.query_evaluator_variants_request_order import QueryEvaluatorVariantsRequestOrder

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEvaluatorsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_evaluator(
        self,
        *,
        evaluator: EvaluatorCreate,
        evaluator_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator : EvaluatorCreate

        evaluator_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/",
            method="POST",
            params={
                "evaluator_id": evaluator_id,
            },
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_evaluator(
        self, evaluator_id: str, *, evaluator: EvaluatorEdit, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        evaluator : EvaluatorEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}",
            method="PUT",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_evaluators(
        self,
        *,
        evaluator: typing.Optional[EvaluatorQuery] = OMIT,
        evaluator_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        include_archived: typing.Optional[bool] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorsResponse]:
        """
        Parameters
        ----------
        evaluator : typing.Optional[EvaluatorQuery]

        evaluator_refs : typing.Optional[typing.Sequence[Reference]]

        include_archived : typing.Optional[bool]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/query",
            method="POST",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=typing.Optional[EvaluatorQuery], direction="write"
                ),
                "evaluator_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_refs, annotation=typing.Optional[typing.Sequence[Reference]], direction="write"
                ),
                "include_archived": include_archived,
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing, annotation=typing.Optional[Windowing], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorsResponse,
                    parse_obj_as(
                        type_=EvaluatorsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_evaluator_variant(
        self, *, evaluator_variant: EvaluatorVariantCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant : EvaluatorVariantCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/variants/",
            method="POST",
            json={
                "evaluator_variant": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant, annotation=EvaluatorVariantCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_evaluator_variant(
        self, evaluator_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_evaluator_variant(
        self,
        evaluator_variant_id: str,
        *,
        evaluator_variant: EvaluatorVariantEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        evaluator_variant : EvaluatorVariantEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}",
            method="PUT",
            json={
                "evaluator_variant": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant, annotation=EvaluatorVariantEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_evaluator_variant(
        self, evaluator_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_evaluator_variant(
        self, evaluator_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_evaluator_variants(
        self,
        *,
        evaluator_id: typing.Optional[str] = None,
        evaluator_ids: typing.Optional[typing.Sequence[str]] = None,
        evaluator_slug: typing.Optional[str] = None,
        evaluator_slugs: typing.Optional[typing.Sequence[str]] = None,
        evaluator_variant_id: typing.Optional[str] = None,
        evaluator_variant_ids: typing.Optional[typing.Sequence[str]] = None,
        evaluator_variant_slug: typing.Optional[str] = None,
        evaluator_variant_slugs: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryEvaluatorVariantsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorVariantsResponse]:
        """
        Parameters
        ----------
        evaluator_id : typing.Optional[str]

        evaluator_ids : typing.Optional[typing.Sequence[str]]

        evaluator_slug : typing.Optional[str]

        evaluator_slugs : typing.Optional[typing.Sequence[str]]

        evaluator_variant_id : typing.Optional[str]

        evaluator_variant_ids : typing.Optional[typing.Sequence[str]]

        evaluator_variant_slug : typing.Optional[str]

        evaluator_variant_slugs : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryEvaluatorVariantsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/variants/query",
            method="POST",
            params={
                "evaluator_id": evaluator_id,
                "evaluator_ids": evaluator_ids,
                "evaluator_slug": evaluator_slug,
                "evaluator_slugs": evaluator_slugs,
                "evaluator_variant_id": evaluator_variant_id,
                "evaluator_variant_ids": evaluator_variant_ids,
                "evaluator_variant_slug": evaluator_variant_slug,
                "evaluator_variant_slugs": evaluator_variant_slugs,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantsResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fork_evaluator_variant(
        self,
        *,
        evaluator_variant_id: str,
        evaluator: EvaluatorFork,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        evaluator : EvaluatorFork

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/variants/fork",
            method="POST",
            params={
                "evaluator_variant_id": evaluator_variant_id,
            },
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorFork, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve_evaluator_revision(
        self,
        *,
        evaluator_ref: typing.Optional[Reference] = OMIT,
        evaluator_variant_ref: typing.Optional[Reference] = OMIT,
        evaluator_revision_ref: typing.Optional[Reference] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_ref : typing.Optional[Reference]

        evaluator_variant_ref : typing.Optional[Reference]

        evaluator_revision_ref : typing.Optional[Reference]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/retrieve",
            method="POST",
            json={
                "evaluator_ref": convert_and_respect_annotation_metadata(
                    object_=evaluator_ref, annotation=typing.Optional[Reference], direction="write"
                ),
                "evaluator_variant_ref": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant_ref, annotation=typing.Optional[Reference], direction="write"
                ),
                "evaluator_revision_ref": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision_ref, annotation=typing.Optional[Reference], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_evaluator_revision(
        self, *, evaluator_revision: EvaluatorRevisionCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision : EvaluatorRevisionCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/",
            method="POST",
            json={
                "evaluator_revision": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision, annotation=EvaluatorRevisionCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_evaluator_revision(
        self, evaluator_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_evaluator_revision(
        self,
        evaluator_revision_id: str,
        *,
        evaluator_revision: EvaluatorRevisionEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        evaluator_revision : EvaluatorRevisionEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}",
            method="PUT",
            json={
                "evaluator_revision": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision, annotation=EvaluatorRevisionEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_evaluator_revision(
        self, evaluator_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_evaluator_revision(
        self, evaluator_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_evaluator_revisions(
        self,
        *,
        evaluator_revision: typing.Optional[EvaluatorRevisionQuery] = OMIT,
        evaluator_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        evaluator_variant_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        evaluator_revision_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        include_archived: typing.Optional[bool] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorRevisionsResponse]:
        """
        Parameters
        ----------
        evaluator_revision : typing.Optional[EvaluatorRevisionQuery]

        evaluator_refs : typing.Optional[typing.Sequence[Reference]]

        evaluator_variant_refs : typing.Optional[typing.Sequence[Reference]]

        evaluator_revision_refs : typing.Optional[typing.Sequence[Reference]]

        include_archived : typing.Optional[bool]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/query",
            method="POST",
            json={
                "evaluator_revision": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision, annotation=typing.Optional[EvaluatorRevisionQuery], direction="write"
                ),
                "evaluator_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_refs, annotation=typing.Optional[typing.Sequence[Reference]], direction="write"
                ),
                "evaluator_variant_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant_refs,
                    annotation=typing.Optional[typing.Sequence[Reference]],
                    direction="write",
                ),
                "evaluator_revision_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision_refs,
                    annotation=typing.Optional[typing.Sequence[Reference]],
                    direction="write",
                ),
                "include_archived": include_archived,
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing, annotation=typing.Optional[Windowing], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionsResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def commit_evaluator_revision(
        self,
        *,
        evaluator_revision_commit: EvaluatorRevisionCommit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_commit : EvaluatorRevisionCommit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/commit",
            method="POST",
            json={
                "evaluator_revision_commit": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision_commit, annotation=EvaluatorRevisionCommit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def log_evaluator_revisions(
        self, *, evaluator: EvaluatorRevisionsLog, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorRevisionsResponse]:
        """
        Parameters
        ----------
        evaluator : EvaluatorRevisionsLog

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorRevisionsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/log",
            method="POST",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorRevisionsLog, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionsResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_simple_evaluator(
        self,
        *,
        evaluator: SimpleEvaluatorCreate,
        evaluator_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator : SimpleEvaluatorCreate

        evaluator_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/simple/evaluators/",
            method="POST",
            params={
                "evaluator_id": evaluator_id,
            },
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=SimpleEvaluatorCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def fetch_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def edit_simple_evaluator(
        self,
        evaluator_id: str,
        *,
        evaluator: SimpleEvaluatorEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        evaluator : SimpleEvaluatorEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}",
            method="PUT",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=SimpleEvaluatorEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def archive_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unarchive_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def query_simple_evaluators(
        self,
        *,
        evaluator: typing.Optional[SimpleEvaluatorQuery] = OMIT,
        evaluator_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        include_archived: typing.Optional[bool] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SimpleEvaluatorsResponse]:
        """
        Parameters
        ----------
        evaluator : typing.Optional[SimpleEvaluatorQuery]

        evaluator_refs : typing.Optional[typing.Sequence[Reference]]

        include_archived : typing.Optional[bool]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "preview/simple/evaluators/query",
            method="POST",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=typing.Optional[SimpleEvaluatorQuery], direction="write"
                ),
                "evaluator_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_refs, annotation=typing.Optional[typing.Sequence[Reference]], direction="write"
                ),
                "include_archived": include_archived,
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing, annotation=typing.Optional[Windowing], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorsResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def transfer_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}/transfer",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_evaluators_endpoint(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[LegacyEvaluator]]:
        """
        Endpoint to fetch a list of evaluators.

        Returns:
            List[Evaluator]: A list of evaluator objects.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[LegacyEvaluator]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluators",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[LegacyEvaluator],
                    parse_obj_as(
                        type_=typing.List[LegacyEvaluator],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def evaluator_data_map(
        self,
        *,
        inputs: typing.Dict[str, typing.Any],
        mapping: typing.Dict[str, typing.Any],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorMappingOutputInterface]:
        """
        Endpoint to map the experiment data tree to evaluator interface.

        Args:
            request (Request): The request object.
            payload (EvaluatorMappingInputInterface): The payload containing the request data.

        Returns:
            EvaluatorMappingOutputInterface: the evaluator mapping output object

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Any]

        mapping : typing.Dict[str, typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorMappingOutputInterface]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluators/map",
            method="POST",
            json={
                "inputs": inputs,
                "mapping": mapping,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorMappingOutputInterface,
                    parse_obj_as(
                        type_=EvaluatorMappingOutputInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def evaluator_run(
        self,
        evaluator_key: str,
        *,
        inputs: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        settings: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        credentials: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorOutputInterface]:
        """
        Endpoint to evaluate LLM app run

        Args:
            request (Request): The request object.
            evaluator_key (str): The key of the evaluator.
            payload (EvaluatorInputInterface): The payload containing the request data.

        Returns:
            result: EvaluatorOutputInterface object containing the outputs.

        Parameters
        ----------
        evaluator_key : str

        inputs : typing.Optional[typing.Dict[str, typing.Any]]

        settings : typing.Optional[typing.Dict[str, typing.Any]]

        credentials : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorOutputInterface]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(evaluator_key)}/run",
            method="POST",
            json={
                "inputs": inputs,
                "settings": settings,
                "credentials": credentials,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorOutputInterface,
                    parse_obj_as(
                        type_=EvaluatorOutputInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_evaluator_configs(
        self, *, app_id: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[EvaluatorConfig]]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
            app_id (str): The ID of the app.

        Returns:
            List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters
        ----------
        app_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[EvaluatorConfig]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluators/configs",
            method="GET",
            params={
                "app_id": app_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[EvaluatorConfig],
                    parse_obj_as(
                        type_=typing.List[EvaluatorConfig],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_new_evaluator_config(
        self,
        *,
        name: str,
        evaluator_key: str,
        settings_values: typing.Dict[str, typing.Any],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorConfig]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
            app_id (str): The ID of the app.

        Returns:
            EvaluatorConfigDB: Evaluator configuration api model.

        Parameters
        ----------
        name : str

        evaluator_key : str

        settings_values : typing.Dict[str, typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorConfig]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluators/configs",
            method="POST",
            json={
                "name": name,
                "evaluator_key": evaluator_key,
                "settings_values": settings_values,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorConfig,
                    parse_obj_as(
                        type_=EvaluatorConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_evaluator_config(
        self, evaluator_config_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorConfig]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Returns:
            List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters
        ----------
        evaluator_config_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorConfig]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/configs/{jsonable_encoder(evaluator_config_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorConfig,
                    parse_obj_as(
                        type_=EvaluatorConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_evaluator_config(
        self,
        evaluator_config_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        evaluator_key: typing.Optional[str] = OMIT,
        settings_values: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorConfig]:
        """
        Endpoint to update evaluator configurations for a specific app.

        Returns:
            List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters
        ----------
        evaluator_config_id : str

        name : typing.Optional[str]

        evaluator_key : typing.Optional[str]

        settings_values : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorConfig]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/configs/{jsonable_encoder(evaluator_config_id)}",
            method="PUT",
            json={
                "name": name,
                "evaluator_key": evaluator_key,
                "settings_values": settings_values,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorConfig,
                    parse_obj_as(
                        type_=EvaluatorConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_evaluator_config(
        self, evaluator_config_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[bool]:
        """
        Endpoint to delete a specific evaluator configuration.

        Args:
            evaluator_config_id (str): The unique identifier of the evaluator configuration.

        Returns:
            bool: True if deletion was successful, False otherwise.

        Parameters
        ----------
        evaluator_config_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[bool]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/configs/{jsonable_encoder(evaluator_config_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    bool,
                    parse_obj_as(
                        type_=bool,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEvaluatorsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_evaluator(
        self,
        *,
        evaluator: EvaluatorCreate,
        evaluator_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator : EvaluatorCreate

        evaluator_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/",
            method="POST",
            params={
                "evaluator_id": evaluator_id,
            },
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_evaluator(
        self, evaluator_id: str, *, evaluator: EvaluatorEdit, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        evaluator : EvaluatorEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}",
            method="PUT",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/{jsonable_encoder(evaluator_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    parse_obj_as(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_evaluators(
        self,
        *,
        evaluator: typing.Optional[EvaluatorQuery] = OMIT,
        evaluator_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        include_archived: typing.Optional[bool] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorsResponse]:
        """
        Parameters
        ----------
        evaluator : typing.Optional[EvaluatorQuery]

        evaluator_refs : typing.Optional[typing.Sequence[Reference]]

        include_archived : typing.Optional[bool]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/query",
            method="POST",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=typing.Optional[EvaluatorQuery], direction="write"
                ),
                "evaluator_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_refs, annotation=typing.Optional[typing.Sequence[Reference]], direction="write"
                ),
                "include_archived": include_archived,
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing, annotation=typing.Optional[Windowing], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorsResponse,
                    parse_obj_as(
                        type_=EvaluatorsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_evaluator_variant(
        self, *, evaluator_variant: EvaluatorVariantCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant : EvaluatorVariantCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/variants/",
            method="POST",
            json={
                "evaluator_variant": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant, annotation=EvaluatorVariantCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_evaluator_variant(
        self, evaluator_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_evaluator_variant(
        self,
        evaluator_variant_id: str,
        *,
        evaluator_variant: EvaluatorVariantEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        evaluator_variant : EvaluatorVariantEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}",
            method="PUT",
            json={
                "evaluator_variant": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant, annotation=EvaluatorVariantEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_evaluator_variant(
        self, evaluator_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_evaluator_variant(
        self, evaluator_variant_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/variants/{jsonable_encoder(evaluator_variant_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_evaluator_variants(
        self,
        *,
        evaluator_id: typing.Optional[str] = None,
        evaluator_ids: typing.Optional[typing.Sequence[str]] = None,
        evaluator_slug: typing.Optional[str] = None,
        evaluator_slugs: typing.Optional[typing.Sequence[str]] = None,
        evaluator_variant_id: typing.Optional[str] = None,
        evaluator_variant_ids: typing.Optional[typing.Sequence[str]] = None,
        evaluator_variant_slug: typing.Optional[str] = None,
        evaluator_variant_slugs: typing.Optional[typing.Sequence[str]] = None,
        name: typing.Optional[str] = None,
        description: typing.Optional[str] = None,
        flags: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        meta: typing.Optional[str] = None,
        include_archived: typing.Optional[bool] = None,
        next: typing.Optional[str] = None,
        newest: typing.Optional[dt.datetime] = None,
        oldest: typing.Optional[dt.datetime] = None,
        limit: typing.Optional[int] = None,
        order: typing.Optional[QueryEvaluatorVariantsRequestOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorVariantsResponse]:
        """
        Parameters
        ----------
        evaluator_id : typing.Optional[str]

        evaluator_ids : typing.Optional[typing.Sequence[str]]

        evaluator_slug : typing.Optional[str]

        evaluator_slugs : typing.Optional[typing.Sequence[str]]

        evaluator_variant_id : typing.Optional[str]

        evaluator_variant_ids : typing.Optional[typing.Sequence[str]]

        evaluator_variant_slug : typing.Optional[str]

        evaluator_variant_slugs : typing.Optional[typing.Sequence[str]]

        name : typing.Optional[str]

        description : typing.Optional[str]

        flags : typing.Optional[str]

        tags : typing.Optional[str]

        meta : typing.Optional[str]

        include_archived : typing.Optional[bool]

        next : typing.Optional[str]

        newest : typing.Optional[dt.datetime]

        oldest : typing.Optional[dt.datetime]

        limit : typing.Optional[int]

        order : typing.Optional[QueryEvaluatorVariantsRequestOrder]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/variants/query",
            method="POST",
            params={
                "evaluator_id": evaluator_id,
                "evaluator_ids": evaluator_ids,
                "evaluator_slug": evaluator_slug,
                "evaluator_slugs": evaluator_slugs,
                "evaluator_variant_id": evaluator_variant_id,
                "evaluator_variant_ids": evaluator_variant_ids,
                "evaluator_variant_slug": evaluator_variant_slug,
                "evaluator_variant_slugs": evaluator_variant_slugs,
                "name": name,
                "description": description,
                "flags": flags,
                "tags": tags,
                "meta": meta,
                "include_archived": include_archived,
                "next": next,
                "newest": serialize_datetime(newest) if newest is not None else None,
                "oldest": serialize_datetime(oldest) if oldest is not None else None,
                "limit": limit,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantsResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fork_evaluator_variant(
        self,
        *,
        evaluator_variant_id: str,
        evaluator: EvaluatorFork,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorVariantResponse]:
        """
        Parameters
        ----------
        evaluator_variant_id : str

        evaluator : EvaluatorFork

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorVariantResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/variants/fork",
            method="POST",
            params={
                "evaluator_variant_id": evaluator_variant_id,
            },
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorFork, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorVariantResponse,
                    parse_obj_as(
                        type_=EvaluatorVariantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve_evaluator_revision(
        self,
        *,
        evaluator_ref: typing.Optional[Reference] = OMIT,
        evaluator_variant_ref: typing.Optional[Reference] = OMIT,
        evaluator_revision_ref: typing.Optional[Reference] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_ref : typing.Optional[Reference]

        evaluator_variant_ref : typing.Optional[Reference]

        evaluator_revision_ref : typing.Optional[Reference]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/retrieve",
            method="POST",
            json={
                "evaluator_ref": convert_and_respect_annotation_metadata(
                    object_=evaluator_ref, annotation=typing.Optional[Reference], direction="write"
                ),
                "evaluator_variant_ref": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant_ref, annotation=typing.Optional[Reference], direction="write"
                ),
                "evaluator_revision_ref": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision_ref, annotation=typing.Optional[Reference], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_evaluator_revision(
        self, *, evaluator_revision: EvaluatorRevisionCreate, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision : EvaluatorRevisionCreate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/",
            method="POST",
            json={
                "evaluator_revision": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision, annotation=EvaluatorRevisionCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_evaluator_revision(
        self, evaluator_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_evaluator_revision(
        self,
        evaluator_revision_id: str,
        *,
        evaluator_revision: EvaluatorRevisionEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        evaluator_revision : EvaluatorRevisionEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}",
            method="PUT",
            json={
                "evaluator_revision": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision, annotation=EvaluatorRevisionEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_evaluator_revision(
        self, evaluator_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_evaluator_revision(
        self, evaluator_revision_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/evaluators/revisions/{jsonable_encoder(evaluator_revision_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_evaluator_revisions(
        self,
        *,
        evaluator_revision: typing.Optional[EvaluatorRevisionQuery] = OMIT,
        evaluator_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        evaluator_variant_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        evaluator_revision_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        include_archived: typing.Optional[bool] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorRevisionsResponse]:
        """
        Parameters
        ----------
        evaluator_revision : typing.Optional[EvaluatorRevisionQuery]

        evaluator_refs : typing.Optional[typing.Sequence[Reference]]

        evaluator_variant_refs : typing.Optional[typing.Sequence[Reference]]

        evaluator_revision_refs : typing.Optional[typing.Sequence[Reference]]

        include_archived : typing.Optional[bool]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/query",
            method="POST",
            json={
                "evaluator_revision": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision, annotation=typing.Optional[EvaluatorRevisionQuery], direction="write"
                ),
                "evaluator_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_refs, annotation=typing.Optional[typing.Sequence[Reference]], direction="write"
                ),
                "evaluator_variant_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_variant_refs,
                    annotation=typing.Optional[typing.Sequence[Reference]],
                    direction="write",
                ),
                "evaluator_revision_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision_refs,
                    annotation=typing.Optional[typing.Sequence[Reference]],
                    direction="write",
                ),
                "include_archived": include_archived,
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing, annotation=typing.Optional[Windowing], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionsResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def commit_evaluator_revision(
        self,
        *,
        evaluator_revision_commit: EvaluatorRevisionCommit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorRevisionResponse]:
        """
        Parameters
        ----------
        evaluator_revision_commit : EvaluatorRevisionCommit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/commit",
            method="POST",
            json={
                "evaluator_revision_commit": convert_and_respect_annotation_metadata(
                    object_=evaluator_revision_commit, annotation=EvaluatorRevisionCommit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def log_evaluator_revisions(
        self, *, evaluator: EvaluatorRevisionsLog, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorRevisionsResponse]:
        """
        Parameters
        ----------
        evaluator : EvaluatorRevisionsLog

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorRevisionsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/evaluators/revisions/log",
            method="POST",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=EvaluatorRevisionsLog, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorRevisionsResponse,
                    parse_obj_as(
                        type_=EvaluatorRevisionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_simple_evaluator(
        self,
        *,
        evaluator: SimpleEvaluatorCreate,
        evaluator_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator : SimpleEvaluatorCreate

        evaluator_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/simple/evaluators/",
            method="POST",
            params={
                "evaluator_id": evaluator_id,
            },
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=SimpleEvaluatorCreate, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def fetch_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def edit_simple_evaluator(
        self,
        evaluator_id: str,
        *,
        evaluator: SimpleEvaluatorEdit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        evaluator : SimpleEvaluatorEdit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}",
            method="PUT",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=SimpleEvaluatorEdit, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def archive_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unarchive_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def query_simple_evaluators(
        self,
        *,
        evaluator: typing.Optional[SimpleEvaluatorQuery] = OMIT,
        evaluator_refs: typing.Optional[typing.Sequence[Reference]] = OMIT,
        include_archived: typing.Optional[bool] = OMIT,
        windowing: typing.Optional[Windowing] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SimpleEvaluatorsResponse]:
        """
        Parameters
        ----------
        evaluator : typing.Optional[SimpleEvaluatorQuery]

        evaluator_refs : typing.Optional[typing.Sequence[Reference]]

        include_archived : typing.Optional[bool]

        windowing : typing.Optional[Windowing]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "preview/simple/evaluators/query",
            method="POST",
            json={
                "evaluator": convert_and_respect_annotation_metadata(
                    object_=evaluator, annotation=typing.Optional[SimpleEvaluatorQuery], direction="write"
                ),
                "evaluator_refs": convert_and_respect_annotation_metadata(
                    object_=evaluator_refs, annotation=typing.Optional[typing.Sequence[Reference]], direction="write"
                ),
                "include_archived": include_archived,
                "windowing": convert_and_respect_annotation_metadata(
                    object_=windowing, annotation=typing.Optional[Windowing], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorsResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def transfer_simple_evaluator(
        self, evaluator_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SimpleEvaluatorResponse]:
        """
        Parameters
        ----------
        evaluator_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SimpleEvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"preview/simple/evaluators/{jsonable_encoder(evaluator_id)}/transfer",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SimpleEvaluatorResponse,
                    parse_obj_as(
                        type_=SimpleEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_evaluators_endpoint(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[LegacyEvaluator]]:
        """
        Endpoint to fetch a list of evaluators.

        Returns:
            List[Evaluator]: A list of evaluator objects.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[LegacyEvaluator]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluators",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[LegacyEvaluator],
                    parse_obj_as(
                        type_=typing.List[LegacyEvaluator],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def evaluator_data_map(
        self,
        *,
        inputs: typing.Dict[str, typing.Any],
        mapping: typing.Dict[str, typing.Any],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorMappingOutputInterface]:
        """
        Endpoint to map the experiment data tree to evaluator interface.

        Args:
            request (Request): The request object.
            payload (EvaluatorMappingInputInterface): The payload containing the request data.

        Returns:
            EvaluatorMappingOutputInterface: the evaluator mapping output object

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Any]

        mapping : typing.Dict[str, typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorMappingOutputInterface]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluators/map",
            method="POST",
            json={
                "inputs": inputs,
                "mapping": mapping,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorMappingOutputInterface,
                    parse_obj_as(
                        type_=EvaluatorMappingOutputInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def evaluator_run(
        self,
        evaluator_key: str,
        *,
        inputs: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        settings: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        credentials: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorOutputInterface]:
        """
        Endpoint to evaluate LLM app run

        Args:
            request (Request): The request object.
            evaluator_key (str): The key of the evaluator.
            payload (EvaluatorInputInterface): The payload containing the request data.

        Returns:
            result: EvaluatorOutputInterface object containing the outputs.

        Parameters
        ----------
        evaluator_key : str

        inputs : typing.Optional[typing.Dict[str, typing.Any]]

        settings : typing.Optional[typing.Dict[str, typing.Any]]

        credentials : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorOutputInterface]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(evaluator_key)}/run",
            method="POST",
            json={
                "inputs": inputs,
                "settings": settings,
                "credentials": credentials,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorOutputInterface,
                    parse_obj_as(
                        type_=EvaluatorOutputInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_evaluator_configs(
        self, *, app_id: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[EvaluatorConfig]]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
            app_id (str): The ID of the app.

        Returns:
            List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters
        ----------
        app_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[EvaluatorConfig]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluators/configs",
            method="GET",
            params={
                "app_id": app_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[EvaluatorConfig],
                    parse_obj_as(
                        type_=typing.List[EvaluatorConfig],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_new_evaluator_config(
        self,
        *,
        name: str,
        evaluator_key: str,
        settings_values: typing.Dict[str, typing.Any],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorConfig]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Args:
            app_id (str): The ID of the app.

        Returns:
            EvaluatorConfigDB: Evaluator configuration api model.

        Parameters
        ----------
        name : str

        evaluator_key : str

        settings_values : typing.Dict[str, typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorConfig]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluators/configs",
            method="POST",
            json={
                "name": name,
                "evaluator_key": evaluator_key,
                "settings_values": settings_values,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorConfig,
                    parse_obj_as(
                        type_=EvaluatorConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_evaluator_config(
        self, evaluator_config_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorConfig]:
        """
        Endpoint to fetch evaluator configurations for a specific app.

        Returns:
            List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters
        ----------
        evaluator_config_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorConfig]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/configs/{jsonable_encoder(evaluator_config_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorConfig,
                    parse_obj_as(
                        type_=EvaluatorConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_evaluator_config(
        self,
        evaluator_config_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        evaluator_key: typing.Optional[str] = OMIT,
        settings_values: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorConfig]:
        """
        Endpoint to update evaluator configurations for a specific app.

        Returns:
            List[EvaluatorConfigDB]: A list of evaluator configuration objects.

        Parameters
        ----------
        evaluator_config_id : str

        name : typing.Optional[str]

        evaluator_key : typing.Optional[str]

        settings_values : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorConfig]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/configs/{jsonable_encoder(evaluator_config_id)}",
            method="PUT",
            json={
                "name": name,
                "evaluator_key": evaluator_key,
                "settings_values": settings_values,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorConfig,
                    parse_obj_as(
                        type_=EvaluatorConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_evaluator_config(
        self, evaluator_config_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[bool]:
        """
        Endpoint to delete a specific evaluator configuration.

        Args:
            evaluator_config_id (str): The unique identifier of the evaluator configuration.

        Returns:
            bool: True if deletion was successful, False otherwise.

        Parameters
        ----------
        evaluator_config_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[bool]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/configs/{jsonable_encoder(evaluator_config_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    bool,
                    parse_obj_as(
                        type_=bool,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
